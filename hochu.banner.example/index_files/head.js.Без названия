
try {
  (function (w, d) {



  var widgetsCfg = {
   "tPPzC_c2iXOJ39_f" : {
      "user_id" : "SDBINLA0RsU4XwgN",
      "id" : "tPPzC_c2iXOJ39_f",
      "payload" : {
         "responsiveTitleFont" : 0,
         "illustrationType" : "standard",
         "hasPreloader" : "1",
         "te" : [],
         "blockTitleFont" : "georgia",
         "titleFontStyle" : "normal",
         "descriptionMarginTop" : "",
         "widgetTitleEdited" : "Стандартный виджет",
         "no_image" : 0,
         "gaClickValueType" : "none",
         "gaLoadLabel" : "",
         "insertBeforeElemSelect" : "",
         "blockTitleLineHeight" : "32px",
         "gaLoadCategory" : "",
         "illustrationSize" : 6,
         "waitForElemTimeout" : "",
         "descriptionLineHeight" : "",
         "title" : "Для нового дизайна 2016",
         "gaShowLabel" : "",
         "gaClickLabel" : "",
         "descriptionFontWeight" : "400",
         "with_footer" : 0,
         "titleFontSize" : "19px",
         "utm_hash_from" : "",
         "cutTextUntilThumbnailBottom" : 0,
         "hasImages" : "1",
         "gaClickOnce" : 0,
         "with_linkless_brand" : 0,
         "custom_recs_file" : "",
         "descriptionFontStyle" : "normal",
         "blockTitleFontStyle" : "normal",
         "titleLineHeight" : "24px",
         "cols" : "3",
         "windowMinWidth" : "",
         "descLinesCount" : "5",
         "openInNewTab" : 0,
         "external_recs_template" : "",
         "descriptionFont" : "georgia",
         "gaLoadOnce" : 1,
         "underHeaderLine" : "1",
         "font" : "arial",
         "theme" : "default",
         "preserve_rows_quantity" : 0,
         "currentTestVariant" : null,
         "adSlotManager" : [
            0,
            1,
            0,
            0,
            1,
            0
         ],
         "advBlocksCount" : 1,
         "noAnchorNeeded" : 1,
         "gaLoadAction" : "",
         "with_description" : 0,
         "blockTitleFontWeight" : "400",
         "gaShowAction" : "",
         "gaClickCategory" : "",
         "with_block_title" : 0,
         "gaShowCategory" : "",
         "loadPriority" : 200,
         "rows" : "2",
         "utm_from" : "",
         "gaClickAction" : "",
         "descriptionFontSize" : "",
         "titleMarginTop" : "5px",
         "widgetType" : "plain",
         "clickableItem" : "1",
         "onlyAdsNeeded" : 0,
         "gaShowOnce" : 1,
         "with_brand" : 1,
         "titleFontWeight" : "400",
         "windowMaxWidth" : "",
         "headLinesCount" : "3",
         "view" : "plates",
         "blockTitleFontSize" : "32px",
         "presetName" : "footerPlates",
         "adLabel" : "",
         "with_title" : "1",
         "titleFont" : "georgia",
         "ignoreAgeCheck" : 0
      },
      "company_id" : "SDBINLA0RsU4XwgN",
      "domain_id" : "Du3eOg",
      "is_enabled" : true
   }
}
;
  var widgetKeys = [];

  for (var key in widgetsCfg) {
    widgetKeys[key] = null;
  }

  
  var extConfig = {
   "pCYNWw" : {
      "type" : "img",
      "src" : "https://cookiefwd.buzzoola.com/forward?redirect_url=https%3A%2F%2Frelap.io%2Fapi%2Fpartners%2Fbzcs.gif%3F_s%3DJ7mizg%26c%3D%7Bbuzz_cookie%7D",
      "timeout" : 1000
   },
   "63rReg" : {
      "src" : "https://recreativ.ru/mtch/21/kx9eLPw2?r=https%3A%2F%2Frelap.io%2Fapi%2Fpartners%2Frccs.gif%3Fuid%3D%24UID%26ruid%3D%24SID",
      "type" : "img",
      "timeout" : 500
   },
   "hSBNIQ" : {
      "src" : "https://px.adhigh.net/p/cm/relapio",
      "type" : "img",
      "timeout" : 500
   },
   "KOA1JA" : {
      "timeout" : 500,
      "type" : "img",
      "src" : "https://sync.audtd.com/match/relap?uid="
   },
   "oP_vtA" : {
      "type" : "img",
      "src" : "https://px.adhigh.net/p/cm/relapio",
      "timeout" : 500
   },
   "xV5cwg" : {
      "type" : "jsonp",
      "src" : "https://ad.mail.ru/adq/?q=45459&cpm_floor=1000&sitename=hochu.ua&count=2",
      "timeout" : 2500,
      "callbackParamName" : "callback"
   },
   "vVyH9g" : {
      "timeout" : 500,
      "src" : "https://ssp.adriver.ru/cgi-bin/sync.cgi?ssp_id=42&external_id=kx9eLPw2",
      "type" : "img"
   },
   "ErGwXA" : {
      "callbackParamName" : "callback",
      "timeout" : 2500,
      "src" : "https://cas.criteo.com/delivery/0.1/napi.jsonp?zoneid=439680&publisherid=34239",
      "type" : "jsonp"
   },
   "Ca9FnQ" : {
      "timeout" : 500,
      "type" : "img",
      "src" : "https://sync.audtd.com/match/relap?uid="
   },
   "YCayww" : {
      "name" : "prefetch_mixmarket_biz_openrtb",
      "type" : "token",
      "value" : "AQNCKI:319690"
   },
   "JvPgeA" : {
      "type" : "token",
      "value" : "AQNCKI:319684",
      "name" : "prefetch_adsniper_ru"
   }
}
;
  
  
  extConfig['abp'] = {
    'type':     'js',
    'timeout':  500,
    'code':     function (params, finished) {
      var px           = 'https://relap.io/abp.gif?ch=*&rn=*',
          checksRemain = 2,
          error1       = false,
          error2       = false,
          random       = Math.random() * 11;

      function checkImages() {
        if (--checksRemain) return;
        if (!error1 && error2) params.push({ 'name': 'wlabp', 'value': '1' });
        finished();
      }

      var img1     = new Image();
      img1.onload  = checkImages;
      img1.onerror = function() {
        error1 = true;
        checkImages();
      }
      img1.src = px.replace(/\*/, 1).replace(/\*/, random);

      var img2     = new Image();
      img2.onload  = checkImages;
      img2.onerror = function() {
        error2 = true;
        checkImages();
      }
      img2.src = px.replace(/\*/, 2).replace(/\*/, random);
    }
  };
  
  


  var optsParam = '';
  var opts;

  try {
    opts = decodeURIComponent(optsParam);
    var tmpElem = d.createElement('div');
    tmpElem.innerHTML = opts;

    opts = JSON.parse(tmpElem.textContent);
  } catch (e) {
    opts = {};
  }

  
  if (opts.restart) {
    delete w.relap;
    delete w.relapStatGathered;
  }

  
  if (w.relap) {
    debugLog("head.js should be one", "warn");
    log('In the End, there can be only one');
    return;
  }

  log('widgetsCfg');
  log(widgetsCfg);
  log('extConfig');
  log(extConfig);

  var targetUrl = 'http://hochu.ua/cat-health/womens/article-74222-pigmentnyie-pyatna-kakimi-oni-byivayut-i-kak-s-nimi-borotsya/';
  getTargetUrl();

  debugLog(targetUrl, "url");

  var seed = 'NOJ2oFwBDpJjhK61GAc';

  onFuncReady({
    funcName: 'relapHeadjsLoaded',
    args: [{
      seed: seed,
    }],
    onError: function() {
      log('relapHeadjsLoaded failed because func is not found for head.js');
    }
  });

  var extParamsReady = false;
  var extParams = [];

  var relap = {
    callbackRegistry: {},
    onLoadImages: makeImgQueue(),
    onShowImages: makeImgQueue(),
    gaEventStatus: {},
    widgetInstances: {},
    swapRec: function(opt) {
      try {
        relap.widgetInstances[opt.widgetInstanceId].swapRec(opt);
      } catch (e) {
        console.log(e);
      }
    },
  };

  w.relap = relap;

  if (!w.relapStatGathered) {
    w.relapStatGathered = true;
    var img = new Image();
    img.src = 'https://relap.io/api/v1/pixel.gif' +
    '?event=hit' +
    '&url=' + encodeURIComponent(w.location.href) +
    '&referrer=' + encodeURIComponent(d.referrer) +
    '&_s=J7mizg' +
    getPageHashParam() ;
  }

  relap.ar = function(id) {
    

    
    return;

    if (!checkWidgetActive(id) ||
        (widgetsCfg[id].payload.noAnchorNeeded &&
        widgetsCfg[id].payload.insertBeforeElemSelect)) {
      return;
    }

    widgetsQueue.push(id);
  };

  relap.loadMore = function() {
    loadMultiAnchor();
    loadInsets();

    function loadMultiAnchor() {
      var multiAnchorElems = d.querySelectorAll('.js-relap-multi-anchor[data-id]:not([data-init])');

      if (!multiAnchorElems.length) return;

      for (var i = 0; i < multiAnchorElems.length; i++) {
        var dataId = multiAnchorElems[i].getAttribute('data-id');
        var widgetCfg = widgetsCfg[dataId];
        if (!widgetCfg) continue;

        widgetCfg.isQueued = false;
        widgetsQueue.push(dataId);
      }
    }

    function loadInsets() {
      for (var key in widgetsCfg) {
        var payload = widgetsCfg[key].payload;

        if (payload.widgetType == 'inset') {
          var widgetCfg = widgetsCfg[key];
          if (!widgetCfg) continue;

          widgetCfg.isQueued = false;
          widgetsQueue.push(key);
        }
      }
    }
  };

  relap.getWidgetCfg = function(id) {
    if (!widgetsCfg[id]) {
      log('relap: wrong anchor id');
      return null;
    }

    return widgetsCfg[id];
  };

  var syncLoader = {
    'queue': [],
    'init': function () {
      var self = this;
      self.queue.push = function (task) {
        Array.prototype.push.apply(self.queue, [task]);
        if (self.queue.length == 1) task();
      }

      self.queue.next = function () {
        self.queue.shift();
        if (self.queue.length > 0) self.queue[0]();
      }
    }
  };
  syncLoader.init();

  var widgetsQueue = (function() {
    var queue = [];

    var processFirstItem = function() {
      if (!queue.length) return;

      var id = queue[0];
      var src = buildSrcString(id);
      log('widgetsQueue next: ' + widgetsCfg[id].payload.widgetType + ', id: ' + id);
      addWidgetScript(id, src);
    };

    var pubObj = {
      queue: queue,
      push: function(widgetId) {
        if (widgetsCfg[widgetId].isQueued) return;

        widgetsCfg[widgetId].isQueued = true;
        queue.push(widgetId);

        if (!extParamsReady || !queue.length) return;

        if (queue.length == 1) {
          processFirstItem();
        }
      },
      next: function() {
        queue.shift();
        if (queue.length) processFirstItem();
      },
      process: function() {
        processFirstItem();
      }
    };

    return pubObj;
  })();

  var extConfigurer = new ExtConfigurer({
    cfg: extConfig,
    callbackRegPath: 'window.relap.callbackRegistry',
    callbackReg: relap.callbackRegistry,
    extParams: extParams,
    complete: function() {
      log('extParamsReady');
      log(extParams);
      extParamsReady = true;
      widgetsQueue.process();
    }
  });

  
  var docReadyState = d.readyState;
  var addWidgetInstancesIntervalId;
  log('document readyState: ' + d.readyState);
  if (docReadyState == 'complete' ||
      docReadyState == 'loaded' ||
      docReadyState == 'interactive') {
    onDOMContentLoaded();
  } else {
    w.addEventListener('DOMContentLoaded', onDOMContentLoaded, false);

    if (opts.ignore_load_priority) {
      addWidgetInstancesIntervalId = setInterval(addWidgetInstances, 300);
    }
  }

  function getTargetUrl() {
    if (targetUrl) return;

    var relapUrlEl = d.querySelector('meta[name=relap-url]');

    if (relapUrlEl) {
      var relapUrl = relapUrlEl.getAttribute('content');
    }

    if (relapUrl) {
      targetUrl = relapUrl;
      return;
    }

    var canonicalEl = d.querySelector('link[rel=canonical]');

    if (canonicalEl) {
      var canonicalUrl = canonicalEl.getAttribute('href');
    }

    if (canonicalUrl) {
      targetUrl = canonicalUrl;
      return;
    }

    var ogUrlEl = d.querySelector('meta[property=\"og:url\"]');

    if (ogUrlEl) {
      var ogUrl = ogUrlEl.getAttribute('content');
    }

    if (ogUrl) {
      targetUrl = ogUrl;
      return;
    }

    if (w.location.href) {
      targetUrl = w.location.href;
      return;
    }
  }

  function onDOMContentLoaded() {
    addWidgetInstances();
    clearInterval(addWidgetInstancesIntervalId);
    w.removeEventListener('DOMContentLoaded', onDOMContentLoaded, false);
  }

  function addWidgetInstances() {
    if (!d.body) return;

    var arr = [];

    for (var id in widgetsCfg) {
      var payload = widgetsCfg[id].payload;
      var testVariants = payload.testVariants;
      var currentTestVariant = payload.currentTestVariant;
      
      if (testVariants &&
          currentTestVariant &&
          testVariants[currentTestVariant] &&
          testVariants[currentTestVariant].cfg) {
        mixInPayload(testVariants[currentTestVariant].cfg);
      }
      var widgetType = payload.widgetType;

      switch(widgetType) {
        case 'inset':
          payload.loadPriority = payload.loadPriority || 300;
          break;
        case 'plain':
        case 'side':
          payload.loadPriority = payload.loadPriority || 200;
          break;
        case 'toster':
        case 'popup':
        default:
          payload.loadPriority = payload.loadPriority || 100;
          break;
      }

      arr.push(widgetsCfg[id]);
    }

    arr.sort(compareByLoadPriority);

    for (var i = 0; i < arr.length; i++) {
      var id = arr[i].id;
      var anchorEl = d.getElementById(id);
      var multiAnchorElems = d.querySelectorAll('.js-relap-multi-anchor[data-id="' + id + '"]:not([data-init])');

      if (!anchorEl && !multiAnchorElems.length &&
          (!widgetsCfg[id].payload.noAnchorNeeded ||
          !widgetsCfg[id].payload.insertBeforeElemSelect) &&
          (widgetsCfg[id].payload.widgetType != 'inset' &&
          widgetsCfg[id].payload.widgetType != 'toster' &&
          widgetsCfg[id].payload.widgetType != 'popup')) {

        debugStatus(id, "warn", "widget_not_required");
        debugEnd(id);
        continue;
      }

      log('widgetsQueue.push: ' + widgetsCfg[id].payload.widgetType + ', id: '+ id);
      widgetsQueue.push(id);
    }

    function compareByLoadPriority(a, b) {
      return b.payload.loadPriority - a.payload.loadPriority;
    }

    function mixInPayload(obj) {
      for (var key in obj) {
        if (!obj.hasOwnProperty(key) || !obj[key]) continue;
        payload[key] = obj[key];
      }
    }
  }

  function checkWidgetActive(id) {
    if (!widgetsCfg[id]) {
      log('relap: wrong anchor id: ' + id);
      return false;
    }

    if (!widgetsCfg[id].is_enabled) {
      return false;
    }

    return true;
  }

  function makeImgQueue() {
    var arr = [];
    arr.queue = function(newArr) {
      for (var i = 0; i < newArr.length; i++) {
        if (!checkIsUnique(newArr[i])) continue;
        arr.push(newArr[i]);
      }

      process();
    };

    return arr;

    function checkIsUnique(imgObj) {
      for (var i = 0; i < arr.length; i++) {
        if (imgObj.src == arr[i].src) return false;
      }

      return true;
    }

    function process() {
      for (var i = 0; i < arr.length; i++) {
        if (arr[i].loadComplete || arr[i].loadStarted) continue;
        loadImg(arr[i]);
      }

      function loadImg(imgObj) {
        var timeout = imgObj.timeout || 500;
        imgObj.loadStarted = true;

        var timeoutId = setTimeout(function() {
          imgObj.loadComplete = true;
        }, timeout);

        var img = new Image();
        img.onload = img.onerror = function() {
          log('extStat img loaded/error: ' + imgObj.src);
          clearTimeout(timeoutId);
          imgObj.loadComplete = true;
        };

        img.src = imgObj.src;
      }
    }
  }

  function buildSrcString(id) {
    if (!widgetsCfg[id]) return;

    var payload = widgetsCfg[id].payload;
    payload.anchorId = id;
    payload.seed = seed;
    payload.widget_id = id;

    if (targetUrl) {
      payload.url = targetUrl;
    }

    
    var URLStart = 'https://relap.io/api/v6/similar_pages.js';
    
    var src = buildRequestURL(URLStart, payload);
    return src;
  }

  function buildRequestURL(URLStart, payload) {
    var paramStr = [];
    var string = '';

    for (var key in payload) {
      paramStr.push(key + '=' + encodeURIComponent(payload[key]));
    }

    var url = URLStart + '?' + paramStr.join('&');

    if (extParams.length) url += '&' + extParams.join('&');

    return url;
  }

  function addWidgetScript(id, src) {
    log('addWidgetScript: ' + widgetsCfg[id].payload.widgetType + ', id: ' + id);
    positionScript({
      id: id,
      src: src,
      onComplete: function(scriptPosObj, id, src) {
        log('onPositionScriptComplete: ' + widgetsCfg[id].payload.widgetType + ', id: ' + id);
        var anchor = scriptPosObj.anchor;
        var scriptParent = scriptPosObj.scriptParent;
        var insertBeforeElem = scriptPosObj.insertBeforeElem;

        if (scriptPosObj.multiAnchorElems && scriptPosObj.multiAnchorElems.length) {
          handleMultiAnchorElems(scriptPosObj.multiAnchorElems, id, src);
          return;
        }

        if (scriptPosObj.multiArticleConfig && scriptPosObj.multiArticleConfig.length) {
          handleInsetWidgets(scriptPosObj.multiArticleConfig, id, src);
          return;
        }

        if (!scriptParent) {
          log('no scriptParent for id: ' + id);
          widgetsQueue.next();
          debugStatus(id, "error", "script_parent_not_found");
          debugEnd(id);
          return;
        }

        if (scriptPosObj.noAnchorOrInsertBeforeElemSelect) {
          log('no anchor or insertBeforeElemSelect present for id: ' + id);
          widgetsQueue.next();
          debugStatus(id, "error", "no_anchor_or_insertBeforeElemSelect_present");
          debugEnd(id);
          return;
        }

        syncLoader.queue.push(createSyncTask({
          id: id,
          src: src,
          scriptParent: scriptParent,
          insertBeforeElem: insertBeforeElem,
          anchor: anchor
        }));

        function handleMultiAnchorElems(elems, id, src) {
          for (var i = 0; i < elems.length; i++) {
            if (elems[i].getAttribute('data-init')) continue;
            
            elems[i].setAttribute('data-init', 1);

            syncLoader.queue.push(createSyncTask({
              id: id,
              src: src,
              scriptParent: elems[i].parentNode,
              anchor: elems[i]
            }));
          }
        }

        function handleInsetWidgets(configs, id, src) {
          for (var i = 0; i < configs.length; i++) {
            var config = configs[i];

            if (config.forbiddenElemInArticleFound) {
              log('forbidden element in article found for id: ' + id);
              debugStatus(id, "error", "forbidden_elem_in_article_found");
              continue;
            }

            if (config.articleTooShort) {
              log('article is too short for id: ' + id);
              debugStatus(id, "error", "article_is_too_short");
              continue;
            }

            if (config.noParagraphsFound) {
              log('no paragraphs found for id: ' + id);
              debugStatus(id, "error", "no_paragraphs_found");
              continue;
            }

            if (config.paragraphIsNotFound) {
              log('paragraph by number is not found for id: ' + id);
              debugStatus(id, "error", "paragraph_by_number_is_not_found");
              continue;
            }

            if (config.insertBeforeElem.getAttribute('data-relap-init')) continue;
            
            config.insertBeforeElem.setAttribute('data-relap-init', 1);

            syncLoader.queue.push(createSyncTask({
              id: id,
              src: src,
              scriptParent: config.scriptParent,
              anchor: config.insertBeforeElem
            }));
          }

          widgetsQueue.next();
          debugEnd(id);
        }

        function createSyncTask(opt) {
          var id = opt.id;
          var src = opt.src;
          var scriptParent = opt.scriptParent;
          var insertBeforeElem = opt.insertBeforeElem;
          var anchor = opt.anchor;

          var syncTask = function() {
            var script = d.createElement('script');
            script.className = 'relap-sp_' + id;
            script.onload = script.onerror = function() {
              widgetsQueue.next();
              syncLoader.queue.next();
            };
            script.src = src;

            if (insertBeforeElem) {
              log('insertBeforeElem id: ' + id);
              scriptParent.insertBefore(script, insertBeforeElem);
              return;
            }

            if (anchor) {
              log('insert before anchor id: ' + id);
              scriptParent.insertBefore(script, anchor);
              return;
            }

            log('append to body id: ' + id);
            scriptParent.appendChild(script);
          };

          return syncTask;
        }
      }
    });

    function positionScript(opt) {
      var id = opt.id;
      var src = opt.src;
      var onPositioningComplete = opt.onComplete;

      var positioning = {};
      var scriptParent = d.body;

      var multiAnchorElems = d.querySelectorAll('.js-relap-multi-anchor[data-id="' + id + '"]:not([data-init])');

      if (multiAnchorElems.length) {
        positioning.multiAnchorElems = multiAnchorElems;
      }

      var anchor = d.getElementById(id);

      if (anchor) {
        scriptParent = anchor.parentNode;
        positioning.anchor = anchor;
        debugStatus(id, "success", "anchor_script_found");
      }

      positioning.scriptParent = scriptParent;

      var payload = widgetsCfg[id].payload;
      var multiArticle = payload.multiArticle;
      var articleSelect = payload.articleSelect;
      var articleMinHeight = payload.articleMinHeight;
      var paragraphSelect = payload.paragraphSelect;
      var paragraphMinHeight = payload.paragraphMinHeight;
      var insertBeforePercent = payload.insertBeforePercent;
      var forbiddenElemInArticleSelect = payload.forbiddenElemInArticleSelect;
      var waitForElemTimeout = payload.waitForElemTimeout || 1;
      var isPreview = payload.isPreview;

      if (typeof payload.insertBeforeParagraphNum == 'number') {
        var insertBeforeParagraphNum = payload.insertBeforeParagraphNum - 1;
      }

      debugWidget(id, "widget_type", payload.widgetType);
      debugWidget(id, "widget_theme", payload.theme);
      debugWidget(id, "recommendations_requested", payload.cols*payload.rows);

      if (payload.widgetType == 'inset') {
        debugWidget(id, "multi_article", payload.multiArticle);
        debugWidget(id, "article_select", payload.articleSelect);
        debugWidget(id, "paragraph_select", payload.paragraphSelect);
        debugWidget(id, "insert_before_percent", payload.insertBeforePercent);
        debugWidget(id, "insert_before_paragraph_num", payload.insertBeforeParagraphNum);
      }

      if (!isPreview &&
          articleSelect &&
          paragraphSelect &&
          (typeof insertBeforePercent == 'number' ||
           typeof insertBeforeParagraphNum == 'number')) {
        waitForElems({
          cssSelect: articleSelect,
          multiArticle: multiArticle,
          onError: (function(id) {
            return function() {
              debugEnd(id);
            };
          })(id),
          onComplete: (function(positioning) {
            return onArticleElemsFound;
          })(positioning),
          timeout: waitForElemTimeout * 1000
        });

        return;
      }

      var widgetType = payload.widgetType;

      if (!isPreview && widgetType == 'inset') {
        positioning.scriptParent = null;
        onPositioningComplete(positioning, id, src)
        return;
      }

      var insertBeforeElemSelect = payload.insertBeforeElemSelect;

      if (!isPreview && insertBeforeElemSelect) {
        waitForElem({
          cssSelect: insertBeforeElemSelect,
          onError: (function(id) {
            return function() {
              debugEnd(id);
            };
          })(id),
          onComplete: (function(positioning) {
            return onInsertBeforeElemFound;
          })(positioning),
          timeout: waitForElemTimeout * 1000
        });

        return;
      }

      if ((widgetType == 'plain' || widgetType == 'side') &&
          !insertBeforeElemSelect && !anchor) {
        positioning.noAnchorOrInsertBeforeElemSelect = true;
      }

      onPositioningComplete(positioning, id, src)


      function waitForElems(opt) {
        var cssSelect = opt.cssSelect;
        var multiArticle = opt.multiArticle;
        var interval = opt.interval || 500;
        var onError = opt.onError;
        var onComplete = opt.onComplete;
        var timeout = opt.timeout || 10000;

        var elems = [];
        intervalFunc();

        if (!elems.length) {
          var intervalId = setInterval(intervalFunc, interval);
        }

        var timeoutId = setTimeout(function() {
          if (elems.length) return;

          log('waitForElem: timed out');
          clearInterval(intervalId);
          onError();
          onComplete(elems);
        }, timeout);

        function intervalFunc() {
          if (multiArticle) {
            elems = d.querySelectorAll(cssSelect);
          } else {
            var elem = d.querySelector(cssSelect);
            if (elem) elems.push(elem);
          }

          if (!elems.length) return;

          log('waitForElems: elems found');
          clearInterval(intervalId);
          onComplete(elems);
        }
      }

      function waitForElem(opt) {
        var cssSelect = opt.cssSelect;
        var interval = opt.interval || 500;
        var onError = opt.onError;
        var onComplete = opt.onComplete;
        var timeout = opt.timeout || 10000;

        var el;
        intervalFunc();

        if (!el) {
          var intervalId = setInterval(intervalFunc, interval);
        }

        var timeoutId = setTimeout(function() {
          if (el) return;

          log('waitForElem: timed out');
          clearInterval(intervalId);
          onError();
          onComplete(el);
        }, timeout);

        function intervalFunc() {
          el = d.querySelector(cssSelect);

          if (!el) return;

          log('waitForElem: elem found');
          clearInterval(intervalId);
          onComplete(el);
        }
      }

      function onArticleElemsFound(articleElems) {
        log('article elem found or timed out, id: ' + id);
        if (!articleElems.length) {
          positioning.scriptParent = null;
          onPositioningComplete(positioning, id, src)
          return;
        }

        positioning.multiArticleConfig = [];

        for (var i = 0; i < articleElems.length; i++) {
          positioning.multiArticleConfig.push({});
        }

        if (forbiddenElemInArticleSelect) {
          for (var i = 0; i < articleElems.length; i++) {
            var forbiddenElemInArticle = articleElems[i]
              .querySelector(forbiddenElemInArticleSelect);

            if (forbiddenElemInArticle) {
              positioning.multiArticleConfig[i].forbiddenElemInArticleFound = true;
              positioning.multiArticleConfig[i].ready = true;
            }
          }
        }

        for (var i = 0; i < articleElems.length; i++) {
          var configItem = positioning.multiArticleConfig[i];
          var articleEl = articleElems[i];

          if (configItem.ready) continue;

          (function(configItem, articleEl) {
            onImagesComplete({
              imgElems: articleEl.getElementsByTagName('img'),
              onComplete: function() {
                var articleHeight = articleEl.offsetHeight;

                if (articleHeight < articleMinHeight) {
                  configItem.articleTooShort = true;
                }

                var paragraphs = articleEl.querySelectorAll(paragraphSelect);

                debugWidget(id, "article_height", articleHeight);
                debugWidget(id, "article_min_height", articleMinHeight);
                debugWidget(id, "paragraphs_found", paragraphs.length);

                if (typeof paragraphMinHeight == 'number') {
                  var tmpArr = [];

                  for (var i = 0; i < paragraphs.length; i++) {
                    var paragraphHeight = paragraphs[i].offsetHeight;

                    if (paragraphHeight < paragraphMinHeight) continue;

                    tmpArr.push(paragraphs[i]);
                  }

                  paragraphs = tmpArr;
                }

                if (!paragraphs.length) {
                  configItem.noParagraphsFound = true;
                }

                var articleElTop = getElemCoords(articleEl).top;

                if (typeof insertBeforePercent == 'number') {
                  var widgetApproximateTop = articleHeight *
                    insertBeforePercent / 100 + articleElTop;

                  for (var i = 0; i < paragraphs.length; i++) {
                    var paragraphTop = getElemCoords(paragraphs[i]).top;
                    if (paragraphTop >= widgetApproximateTop) {
                      configItem.insertBeforeElem = paragraphs[i];
                      configItem.scriptParent = paragraphs[i].parentNode;
                      break;
                    }
                  }

                  if (!configItem.insertBeforeElem && paragraphs.length) {
                    
                    configItem.insertBeforeElem = paragraphs[paragraphs.length - 1];
                    configItem.scriptParent = paragraphs[paragraphs.length - 1].parentNode;
                  }

                  if (!configItem.insertBeforeElem && !paragraphs.length) {
                    
                    configItem.noParagraphsFound = true;
                  }
                }

                if (typeof insertBeforeParagraphNum == 'number') {
                  if (paragraphs[insertBeforeParagraphNum]) {
                    configItem.scriptParent =
                      paragraphs[insertBeforeParagraphNum].parentNode;
                    configItem.insertBeforeElem =
                      paragraphs[insertBeforeParagraphNum];
                  } else {
                    configItem.paragraphIsNotFound = true;
                  }
                }

                configItem.ready = true;
                tryToCompletePositioning(positioning.multiArticleConfig);
              }
            });
          })(configItem, articleEl);
        }

        tryToCompletePositioning(positioning.multiArticleConfig);

        function tryToCompletePositioning(configs) {
          for (var i = 0; i < configs.length; i++) {
            if (!configs[i].ready) return;
          }

          onPositioningComplete(positioning, id, src)
        }
      }

      function onInsertBeforeElemFound(insertBeforeElem) {
        if (!insertBeforeElem) {
          positioning.scriptParent = null;
          onPositioningComplete(positioning, id, src)
          return;
        }

        positioning.scriptParent = insertBeforeElem.parentNode;
        positioning.insertBeforeElem = insertBeforeElem;
        onPositioningComplete(positioning, id, src)
      }
    }
  }

  function log() {
    if (false) w.console.log.apply(w.console, arguments);
  }

  function debugLog(message, prefix_modifier) {
    if (prefix_modifier) {
      prefix_modifier = "--" + prefix_modifier + "--";
    } else {
      prefix_modifier = "";
    }
    log("__relap.io__" + prefix_modifier + message, true);
  }

  function debugEnd(id) {
    delete widgetKeys[id];
    if (getWidgetKeysSize() === 0) debugLog("end");

    function getWidgetKeysSize() {
      var count = 0;
      for (var key in widgetKeys) {
        if (widgetKeys.hasOwnProperty(key)) count++;
      }
      return count;
    }
  }

  function debugWidget(widget_id, key, value) {
    var message = {};
    message[widget_id] = {};
    message[widget_id][key] = value;
    debugLog(JSON.stringify(message));
  }

  function debugStatus(widget_id, status, msg) {
    var message = {};
    message[widget_id] = {status: status, message: msg};
    debugLog(JSON.stringify(message));
  }

  
relap.ExtConfigurer = ExtConfigurer;

function ExtConfigurer(opt) {
  var cfg = opt.cfg;
  var callbackRegPath = opt.callbackRegPath;
  var callbackReg = opt.callbackReg;
  var extParams = opt.extParams;
  var onExtConfigurerComplete = opt.complete;

  var self = this;

  var params = [];
  var firedAway = false;

  var i = 0;

  for (var key in cfg) {
    var cfgItem = cfg[key];

    switch (cfgItem.type) {
      case 'jsonp':
        scriptRequest({
          url: cfgItem.src,
          callbackParamName: cfgItem.callbackParamName,
          success: makeOnSuccessFunc(key),
          error: makeOnErrorFunc(key),
          complete: makeOnCompleteFunc(key),
          timeout: cfgItem.timeout
        });
        break;
      case 'img':
        loadImg(key);
        break;
      case 'vast2.0':
        loadVast_2_0(key);
        break;
      case 'token':
        copyToken(key);
        break;
      case 'js':
        executeJS(key);
        break;
    }

    i++;
  }

  if (i == 0 && onExtConfigurerComplete) onExtConfigurerComplete();

  function scriptRequest(opt) {
    var url = opt.url || '';
    var callbackParamName = opt.callbackParamName || 'callback';
    var success = opt.success;
    var error = opt.error;
    var complete = opt.complete;
    var timeout = opt.timeout || 500;

    var requestSuccess = false;
    var requestCancelled = false;
    var resp = {};

    var callbackName = 'relapCb' + String(Math.random()).slice(-6);

    url += ~url.indexOf('?') ? '&' : '?';
    url += callbackParamName + '=' + callbackRegPath + '.' + callbackName;
    resp.url = url;

    callbackReg[callbackName] = function(data) {
      delete callbackReg[callbackName];
      requestSuccess = true;

      if (requestCancelled) return;

      resp.data = data;

      if (success) success(resp);
      if (complete) complete(resp);
    };

    var scriptEl = d.createElement('script');

        scriptEl.onreadystatechange = function() {
      if (this.readyState == 'complete' || this.readyState == 'loaded') {
        this.onreadystatechange = null;
                setTimeout(cleanCallback, 0); 
      }
    };

        scriptEl.onload = scriptEl.onerror = cleanCallback;
    scriptEl.id = callbackName;
    scriptEl.src = url;

    var headEl = d.getElementsByTagName('head')[0];
    if (headEl) headEl.appendChild(scriptEl);
    if (!scriptEl.parentNode) fallbackAppend(scriptEl);

    var timeoutId = setTimeout(cancelRequest, timeout);

    function cleanCallback() {
            removeScriptEl();

      if (timeoutId) {
        clearTimeout(timeoutId);
        timeoutId = null;
      }

      if (requestSuccess) return;

      delete callbackReg[callbackName];

      if (requestCancelled) return;

      if (error) error(resp);
      if (complete) complete(resp);
    }

    function removeScriptEl() {
      var scriptEl = d.getElementById(callbackName);

      if (scriptEl) {
        scriptEl.parentNode.removeChild(scriptEl);
      }
    }

    function cancelRequest() {
      log('JSONP request cancelled for url: ' + url);
      removeScriptEl();

      timeoutId = null;
      requestCancelled = true;

      if (error) error(resp);
      if (complete) complete(resp);
    }

    function fallbackAppend(scriptEl) {
      log('JSONP fallbackAppend');

      tryToAppend();
      var intervalId = setInterval(tryToAppend, 100);

      function tryToAppend() {
        var divs = d.getElementsByTagName('div');

        for (var i = 0; i < divs.length; i++) {
          divs[i].appendChild(scriptEl);
          if (scriptEl.parentNode) {
            clearInterval(intervalId);
            return;
          }
        }
      }
    }
  }

  function makeOnSuccessFunc(cfgId) {
    return function(resp) {
      if (!resp.data) return;
      log('jsonp success: ' + cfgId);

      if (cfgId == 'xV5cwg' || cfgId == '9Y267g' || cfgId == 'JdzEDw') {
        if (resp.data[0] && resp.data[0]['html']) {
          try {
            /* parse + stringify - чтобы убрать лишние переводы строк и пробелы */
            resp.data[0]['html'] = JSON.stringify(
              JSON.parse(
                /* превращаем callbackName(json) в просто json */
                resp.data[0]['html'].replace(/^[^\[{]+|[^\]}]+$/g, '')
              )
            );
          } catch (e) {
            log('jsonp success: cant shorten response of ' + cfgId + ' because of', e);
          }
        }
      }

      var param = {
        'name': 'ext_json_' + cfgId,
        'value': JSON.stringify(resp.data)
      };

      params.push(param);
    };
  }

  function makeOnErrorFunc(cfgId) {
    return function(resp) {
      log('jsonp error: ' + cfgId);
    };
  }

  function makeOnCompleteFunc(cfgId) {
    return function(resp) {
      log('jsonp complete: ' + cfgId);
      cfg[cfgId].loadComplete = true;
      clearTimeout(cfg[cfgId].timeoutId);
      tryToStartWidgetsLoad();
    };
  }

  function loadImg(cfgId) {
    var timeout = cfg[cfgId].timeout || 500;

    var timeoutId = setTimeout(function() {
      cfg[cfgId].loadComplete = true;
      tryToStartWidgetsLoad();
    }, timeout);

    var img = new Image();
    img.onload = img.onerror = function() {
      log('extConfig img loaded/error: ' + cfgId);
      clearTimeout(timeoutId);
      cfg[cfgId].loadComplete = true;
      tryToStartWidgetsLoad();
    };

    img.src = cfg[cfgId].src;
  }

  function loadVast_2_0(cfgId) {
    var totalTimeout = cfg[cfgId].timeout || 500;
    var vastTimeout = cfg[cfgId].vastTimeout || 200;
    debug('vast debug: start', (new Date()).getTime());

    var fetchUrl = cfg[cfgId].src;
    var urlParts = parseURL(fetchUrl);
    if (urlParts.host == 'ad.mail.ru') {
      fetchUrl = fetchUrl.indexOf('?') === -1 ? fetchUrl + '?' : fetchUrl + '&';
      fetchUrl = fetchUrl + 'dl=' + encodeURIComponent(w.location.toString());
    }

    if (!w.sessionStorage) {
      log("browser doesn't support sessionStorage: " + cfgId);
      cancelRequest('manual');
      return;
    }

    var vastResults = [],
        request,
        timeoutId = setTimeout(cancelRequest, totalTimeout);
    debug('vast debug: total timeout set', totalTimeout, (new Date()).getTime());

    if (cfg[cfgId]['vengovision']) {
        /*
          нужно слать post запрос и параметризовать его в зависимости от клиента
          http://test.sebbia.com/vengovision/help/mediation_vpaid.html
        */
        var device_id = 'relap';
        var domain = 'relap.io';
        var app_id = '-1';
        if(cfg[cfgId]['vengovision']['device_id']) {
          device_id = cfg[cfgId]['vengovision']['device_id'];
        }
        if(cfg[cfgId]['vengovision']['domain']) {
          domain = cfg[cfgId]['vengovision']['domain'];
        }
        if(cfg[cfgId]['vengovision']['app_id']) {
          app_id = cfg[cfgId]['vengovision']['app_id'];
        }

        var postData = {};
        postData['app_id'] = app_id;
        postData['apiver'] = '3.0';
        postData['libplatform'] = 'Web';
        postData['libver'] = '1.0.20';
        postData['dev_width'] = '1920';
        postData['dev_height'] = '1080';
        postData['dev_density'] = '1';
        postData['domain'] = domain;
        postData['locale'] = 'ru';
        postData['device_id'] = device_id;
        postData['type'] = 'insite';
        postData['response_format'] = 'vpaid';
        request = fetchViaPost('https://api.vengovision.ru/', postData);
    }
    else {
        /* логика для всего остального */
        request = fetch(fetchUrl);
    }
    if (!request) {
      log("browser doesn't support XMLHttpRequest: " + cfgId);
      cancelRequest('manual');
      return;
    }

    function debug() {
      if (cfg[cfgId].debug !== 1) return;
      log.apply(w, arguments);
    }

    function vastTrackErrors() {
      vastResults.forEach(function (result) {
        if (!result['Error']) return;
        result.Error.forEach(function (error) { (new Image()).src = error.src });
      });
    }

    function cancelRequest(manual) {
      debug('vast debug: cancelRequest with manual=', manual ? true : false, (new Date()).getTime());
      clearTimeout(timeoutId);
      if (!manual) log('vast global timeout: ' + cfgId);
      if (!manual) vastTrackErrors();
      if (!manual && request) {
        debug('vast debug: aborting request', (new Date()).getTime());
        request.abort();
      }
      cfg[cfgId].loadComplete = true;
      tryToStartWidgetsLoad();
    }

    function fetch(url) {
      log('vast fetching, url is ' + url + ' : ' + cfgId);
      return ajaxRequest(url, null, onAjaxComplete, vastTimeout);
    }

    function fetchViaPost(url, data) {
      log('vast fetching via post, url is ' + url + ' : ' + cfgId);
      log(data);
      return ajaxRequest(url, data, onAjaxComplete, vastTimeout);
    }

    function onAjaxComplete(event) {
      debug('vast debug: onAjaxComplete', (new Date()).getTime());
      if (!event || !event.type || event.type === 'error' || event.type === 'timeout') {
        log('vast load error: ' + cfgId, event);
        vastTrackErrors();
        cancelRequest('manual');

      } else if (event.type === 'load') {
        if (request.responseXML) {
          log('vast load success: ' + cfgId, request.responseXML);

          var vastParsed = parseVast_2_0(request.responseXML);
          debug('vast debug: vastParsed', vastParsed, (new Date()).getTime());
          if (vastResults.length == 0) { /* we were unable to parse vast for some reason */
            /* Красуля говорил, что если по любой причине не смогли показать vast -
               надо дёргать Error; в случае nobanner во вложенном во враппер vast-е тоже */
            vastTrackErrors();
            cancelRequest('manual');
            return;
          }
          if (!vastParsed) return; /* that means vast was referring to another vast, nested request is in progress */

          var linearVast = linearizeVast_2_0(vastResults);
          debug('vast debug: linearVast', linearVast, (new Date()).getTime());
          /*
            Не будем слать весь список медиа фалов на сервер, выберем один лучший,
            который и будем показывать, его и пошлём.
            Для vpaid это js, а не swf.
            Для не vpaid это первый файл
          */
          var chosen = chooseOnlyOneMedia(linearVast);
          debug('vast debug: chosen', chosen, (new Date()).getTime());
          if(chosen.error) {
            log('Choose only one error: [' + chosen.error_code + ']');
            (new Image()).src = 'https://relap.io/d/c/g?counter=count.partners.vast.' + chosen.error_code;
            vastTrackErrors();
          }
          else {
            linearVast = chosen.data;
            var linearVastJSON = JSON.stringify(linearVast);
            sessionStorage.setItem('ext_json_' + cfgId, linearVastJSON);
            if (sessionStorage.getItem('ext_json_' + cfgId) != linearVastJSON) {
              log('sessionStorage support broken');
              (new Image()).src = 'https://relap.io/d/c/g?counter=count.partners.vast.session_storage_broken';
              vastTrackErrors();
            } else {
              params.push({
                'name': 'ext_json_' + cfgId,
                'value': JSON.stringify(getExtConfig(linearVast))
              });
            }
            debug('vast debug: hooray', (new Date()).getTime());
          }
          cancelRequest('manual');

        } else {
          log('vast load error, vast is not xml: ' + cfgId, request.response);
          vastTrackErrors();
          cancelRequest('manual');

        }
      }
    }

    function ajaxRequest(url, postParams, callback, timeout) {
      if (!w.XMLHttpRequest) return;
      var request = new XMLHttpRequest();
      request.addEventListener('load', callback);
      request.addEventListener('error', callback);
      request.addEventListener('timeout', callback);
      request.withCredentials = true;
      if(postParams) {
        var body = [];
        for (var paramName in postParams) {
          body.push(paramName + '=' + encodeURIComponent(postParams[paramName]));
        }
        body = body.join('&');
        request.open('POST', url);
        request.timeout = timeout || 200;
        request.setRequestHeader('Content-Type', 'application/x-www-form-urlencoded');
        request.send(body);
      }
      else {
        request.open('GET', url);
        request.timeout = timeout || 200;
        request.send();
      }
      debug('vast debug: request sent', request, (new Date()).getTime());
      return request;
    }

    /* логика повторяет логику перлового parse в модуле обработки vast 2.0 */
    function parseVast_2_0(xmlDocument) {
      debug('vast debug: parseVast_2_0', (new Date()).getTime());
      var nsResolver = document.createNSResolver(xmlDocument.documentElement);

      var ads = xpathSearch('//Ad', xmlDocument);
      if (ads.length == 0) {
        log('vast parse found no ads: ' + cfgId);
        /*vastResults = [ { 'nobanner': 1 } ];*/
        vastResults = [];
        return;
      }
      if (ads.length > 1) {
        log('vast parse error, more than 1 ad: ' + cfgId);
        vastResults = [];
        return;
      }
      var ad = ads[0];

      var result = {};
      [
        'Error', 'Impression', 'AdParameters', 'ClickThrough', 'ClickTracking',
        { 'node': 'MediaFile', 'attrs': ['type'] },
        { 'node': 'Tracking', 'attrs': ['event'] },
        'VASTAdTagURI', 'StaticResource', 'NonLinearClickThrough'
      ].forEach(function (nodeDefinition) {
        var nodeName, nodeAttrNames;
        if (isString(nodeDefinition)) {
          nodeName = nodeDefinition;
        } else { /* it must be object then */
          nodeName = nodeDefinition.node;
          nodeAttrNames = nodeDefinition.attrs;
        }
        var nodes = xpathSearch('//' + nodeName, ad);
        if (!nodes.length) return;

        /* немного треша и угара */
        nodes.forEach(function (node) {
          var nodeText = node.textContent.trim();
          if (!nodeText) return;

          if (!result[nodeName]) {
            if (nodeName === 'Tracking') {
              result[nodeName] = {};
            } else {
              result[nodeName] = [];
            }
          }
          var nodeResult = { 'src': nodeText };

          if (nodeAttrNames) {
            nodeAttrNames.forEach(function (attrName) {
              var attrText = node.getAttribute(attrName).trim();
              if (!attrText) return;
              if (nodeName === 'Tracking') { /* у Tracking мы должны запрашивать только один атрибут */
                if (!result[nodeName][attrText]) result[nodeName][attrText] = [];
                result[nodeName][attrText].push(nodeResult);
              } else {
                nodeResult[attrName] = attrText;
              }
            });
          }
          if (nodeName !== 'Tracking') {
            result[nodeName].push(nodeResult);
          }
        });

      });
      vastResults.push(result);

      if (result['VASTAdTagURI']) {
        if (vastResults.length >= 3) {
          log('vast error, too many nested vasts: ' + cfgId);
          vastResults = [];
        } else {
          request = fetch(result['VASTAdTagURI'][0].src);
        }
        return;
      }

      if (!result['MediaFile'] && !result['StaticResource'] && !result['nobanner']) {
        log('vast error, bad format: ' + cfgId);
        vastResults = [];
        return;
      }

      return 1;

      function xpathSearch(xpath, node) {
        return nodesSnapshotToArray( xmlDocument.evaluate(xpath, node, nsResolver, XPathResult.ORDERED_NODE_SNAPSHOT_TYPE, null) );
      }

      function nodesSnapshotToArray(xpathResult) {
        var nodes = [];
        for (var i = 0; i < xpathResult.snapshotLength; i++) {
          nodes.push( xpathResult.snapshotItem(i) );
        }
        return nodes;
      }

      function isString(variable) {
        return (typeof variable === 'string' || variable instanceof String);
      }
    }

    function linearizeVast_2_0(vastResults) {
      debug('vast debug: linearizeVast_2_0', (new Date()).getTime());
      var linearized = {};
      vastResults.forEach(function (result) {
        Object.keys(result).forEach(function (nodeName) {
          var item = result[nodeName];
          if (nodeName === 'nobanner') {
            return {};

          } else if (nodeName === 'Tracking') {
            Object.keys(item).forEach(function (event) {
              var linearized_key = nodeName + '_' + event;
              if (!linearized[linearized_key]) linearized[linearized_key] = [];
              item[event].forEach(function (it) {
                linearized[linearized_key].push(it.src);
              });
            });

          } else if (nodeName === 'MediaFile' || nodeName === 'StaticResource') {
            var linearized_key = nodeName;
            if (!linearized[linearized_key]) linearized[linearized_key] = [];
            item.forEach(function (it) {
              linearized[linearized_key].push(it);
            });

          } else {
            var linearized_key = nodeName;
            if (!linearized[linearized_key]) linearized[linearized_key] = [];
            item.forEach(function (it) {
              linearized[linearized_key].push(it.src);
            });

          }
        });
      });

      return linearized;
    }

    function getExtConfig(linearVast) {
      return {
        'MediaFile'   : linearVast['MediaFile'],
        'ClickThrough': linearVast['ClickThrough']
      };
    }

    function chooseOnlyOneMedia(linearVast) {
      debug('vast debug: chooseOnlyOneMedia', (new Date()).getTime());
      var files = linearVast['MediaFile'];
      if(!files) {
        return {error: true, error_code: 'media_file_not_exists'};  
      }
      if(files.length < 1) {
        return {error: true, error_code: 'media_file_empty'};  
      }
      var found_vpaid_flash = false;
      for(var i = 0; i < files.length; i++) {
        var file = files[i];
        if(file['type'] == 'application/javascript') {
          /* vpaid js */
          linearVast['MediaFile'] = [file];
          return {error: false, data: linearVast};
        }
        else if(file['type'] == 'application/x-shockwave-flash') {
          /* vpaid swf */
          found_vpaid_flash = true;
        }
      }
      /* vpaid flash, такое не поддерживаем */
      if(found_vpaid_flash) {
        return {error: true, error_code: 'media_file_vpaid_swf'};  
      }
      /* не vpaid, возьмём первое что есть */
      linearVast['MediaFile'] = [linearVast['MediaFile'][0]];
      return {error: false, data: linearVast};
    }

    function parseURL(url) {
        var a =  document.createElement('a');
        a.href = url;
        /* ваще не факт, что это работает корректно. взято из
        http://james.padolsey.com/javascript/parsing-urls-with-the-dom/,
        и там слетело экранирование некоторых символов в регекспах, кажется */
        return {
          source: url,
          protocol: a.protocol.replace(':',''),
          host: a.hostname,
          port: a.port,
          query: a.search,
          params: (function(){
            var ret = {},
              seg = a.search.replace(/^\?/,'').split('&'),
              len = seg.length, i = 0, s;
            for (;i<len;i++) {
              if (!seg[i]) { continue; }
              s = seg[i].split('=');
              ret[s[0]] = s[1];
            }
            return ret;
          })(),
          file: (a.pathname.match(/\/([^/?#]+)$/i) || [,''])[1],
          hash: a.hash.replace('#',''),
          path: a.pathname.replace(/^([^/])/,'/$1'),
          relative: (a.href.match(/tps?:\/\/[^/]+(.+)/) || [,''])[1],
          segments: a.pathname.replace(/^\//,'').split('/')
      };
    }
  }

  function copyToken(cfgId) {
    cfg[cfgId].loadComplete = true;
    params.push({ name: cfg[cfgId].name, value: cfg[cfgId].value });
  }

  function executeJS(cfgId) {
    var timeout = cfg[cfgId].timeout || 500;
    var code = cfg[cfgId].code || function(params, finished) { finished() };

    var timeoutId = setTimeout(function() {
      log('executeJS timeout for cfgId: ' + cfgId);
      finished();
    }, timeout);

    log('executeJS started for cfgId: ' + cfgId);
    /* вообще срабатывание таймаута не прервёт выполнение кода... так что если 
       он успеет выполниться до момента срабатывания tryToStartWidgetsLoad,
       то свою работу таки успешно сделает */
    code(params, finished);

    function finished() {
      cfg[cfgId].loadComplete = true;
      clearTimeout(timeoutId);
      log('executeJS finished for cfgId: ' + cfgId);
      tryToStartWidgetsLoad();
    };
  }

  function tryToStartWidgetsLoad() {
    if (!checkAllRequestsComplete() || firedAway) return;

    firedAway = true;

    for (var i = 0; i < params.length; i++) {
      extParams.push(params[i].name + '=' +
        encodeURIComponent(params[i].value));
    }

    /* проверим длину богатств и при необходимости укоротим */
    /* сначала отсортируем по важности - служебное в первую очередь, потом мейл,
       потом критео, потом остальное, по возрастанию длины */
    extParams = extParams.sort(function (a, b) {
        return 0 || /* если после return ничего на этой же строке не будет, он вернёт undefined */
            a.indexOf('wlabp=')   === 0   ? -1 : b.indexOf('wlabp=')   === 0   ? 1 :
            a.indexOf('wrdflts=') === 0   ? -1 : b.indexOf('wrdflts=') === 0   ? 1 :
            a.indexOf('ext_json_JdzEDw=') ? -1 : b.indexOf('ext_json_JdzEDw=') ? 1 :
            a.indexOf('ext_json_xV5cwg=') ? -1 : b.indexOf('ext_json_xV5cwg=') ? 1 :
            a.indexOf('ext_json_ErGwXA=') ? -1 : b.indexOf('ext_json_ErGwXA=') ? 1 :
            a.length - b.length
    });
    var extParamsLenLimit = 15000, removed = [];
    var extParamsLen = extParams.reduce(function (acc, val) { return acc + val.length }, 0);
    while (extParamsLen > extParamsLenLimit) {
      log('extParams too long: ' + extParamsLen);
      var lastExtParam = extParams.pop();
      removed.push(lastExtParam);
      log('popped element from extParams:', lastExtParam);
      extParamsLen -= lastExtParam.length;
    }
    /* может статься, что мы выкидывали-выкидывали мелочёвку, этого не хватало,
       а потом выкинули какой-нибудь критео и места хватило. настолько хватило,
       что мелочёвку можно попробовать вернуть */
    removed = removed.sort(function (a, b) { return b.length - a.length });
    while (removed.length && extParamsLen < extParamsLenLimit) {
      var shortestRemovedParam = removed.pop();
      if (shortestRemovedParam.length > extParamsLenLimit - extParamsLen) break;
      log('extParams too short, we can add something back: ' + extParamsLen);
      extParams.push(shortestRemovedParam);
      log('pushed element to extParams:', shortestRemovedParam);
      extParamsLen += shortestRemovedParam.length;
    }

    if (onExtConfigurerComplete) onExtConfigurerComplete();

    function checkAllRequestsComplete() {
      for (var key in cfg) {
        if (!cfg[key].loadComplete) {
          return false;
        }
      }

      return true;
    }
  }
}

  
function onImagesComplete(opt) {
  var imgElems = opt.imgElems;
  var onComplete = opt.onComplete;
  var timeout;
  var interval = opt.interval || 500;

  if (opt.timeout && isFinite(opt.timeout)) {
    timeout = opt.timeout;
  }

  var complete = false;

  var intervalId = setInterval(function() {
    if (checkImagesComplete(imgElems)) {
      clearInterval(intervalId);

      if (complete) return;

      complete = true;
      log('onImagesComplete: images loaded');
      onComplete(imgElems);
    }
  }, interval);

  if (timeout) {
    setTimeout(function() {
      if (complete) return;

      log('onImagesComplete: images considered complete because of timeout');
      clearInterval(intervalId);
      onComplete(imgElems);
    }, timeout);
  }

  function checkImagesComplete(imgElems) {
    for (var i = 0; i < imgElems.length; i++) {
      var isComplete = imgElems[i].complete;

      if (!isComplete) {
        return false;
      }
    }

    return true;
  }
}

  
function getElemCoords(elem) {
  var box = elem.getBoundingClientRect();

  var body = d.body;
  var docEl = d.documentElement;

  var scrollTop = w.pageYOffset || docEl.scrollTop || body.scrollTop;
  var scrollLeft = w.pageXOffset || docEl.scrollLeft || body.scrollLeft;

  var clientTop = docEl.clientTop || body.clientTop || 0;
  var clientLeft = docEl.clientLeft || body.clientLeft || 0;

  var top = box.top + scrollTop - clientTop;
  var left = box.left + scrollLeft - clientLeft;

  return {
    top: top,
    left: left
  };
}

  
function onFuncReady(opt) {
  var funcName = opt.funcName;
  var args = opt.args;
  var onSuccess = opt.onSuccess;
  var onError = opt.onError;
  var onComplete = opt.onComplete;
  var interval = opt.interval || 500;
  var timeout = opt.timeout || (6 * 1000);

  var complete = false;
  intervalFunc();

  if (!complete) {
    var intervalId = setInterval(intervalFunc, interval);
  }

  var timeoutId = setTimeout(function() {
    if (complete) return;

    log('onFuncReady: timed out, gave up');

    try {
      onError();
      onComplete();
    } catch(e) {
    }
    clearInterval(intervalId);
  }, timeout);

  function intervalFunc() {
    if (checkFuncReady()) {
      clearInterval(intervalId);

      if (complete) return;

      complete = true;
      log('onFuncReady: function is ready');

      try {
        w[funcName].apply(this, args);
        onSuccess();
        onComplete();
      } catch(e) {
      }
    }
  }

  function checkFuncReady() {
    if (!w[funcName]) return false;
    if (typeof w[funcName] !== 'function') return false;

    return true;
  }
}

  
relap.ProtoWidget = ProtoWidget;

function ProtoWidget(opt) {
  var widgetId = opt.widgetId;
  var widgetInstanceId = opt.widgetInstanceId;
  var queryParams = opt.queryParams;
  var seed = opt.seed;
  var rgid = opt.rgid;
  var url = opt.url;
  var widgetHTML = opt.widgetHTML;
  var widgetParams = opt.widgetParams;
  var noHandlers = opt.noHandlers;
  var viewPixelSrc = opt.viewPixelSrc;
  var noAnchorNeeded = opt.noAnchorNeeded || false;
  var executeOnWidgetScriptLoad = opt.executeOnWidgetScriptLoad;
  var executeOnWidgetPreloaderShow = opt.executeOnWidgetPreloaderShow;
  var executeOnWidgetReady = opt.executeOnWidgetReady;
  var executeOnWidgetShown = opt.executeOnWidgetShown;
  var executeOnItemClick = opt.executeOnItemClick;
  var pixelSrcStart = opt.pixelSrcStart;
  var pixelClickParamName = opt.pixelClickParamName;
  var pixelSecretSessionParamName = opt.pixelSecretSessionParamName;
  var pixelSecretSessionParam = opt.pixelSecretSessionParam;
  var gaCfg = {
    onLoad: {
      once: widgetParams.gaLoadOnce,
      category: widgetParams.gaLoadCategory,
      action: widgetParams.gaLoadAction,
      label: widgetParams.gaLoadLabel
    },
    onShow: {
      once: widgetParams.gaShowOnce,
      category: widgetParams.gaShowCategory,
      action: widgetParams.gaShowAction,
      label: widgetParams.gaShowLabel
    },
    onClick: {
      once: widgetParams.gaClickOnce,
      category: widgetParams.gaClickCategory,
      action: widgetParams.gaClickAction,
      label: widgetParams.gaClickLabel,
      valueType: widgetParams.gaClickValueType
    }
  };
  
  log('gaCfg');
  log(gaCfg);

  var el;
  var elParent;
  var anchorEl;
  var links;
  var topContainerEl;
  var items;
  var fakeItems;
  var elParentWidth;
  var maxColumnQuantity;
  var scrollHeight;
  var elTop;
  var debouncedOnScrollFunc;
  var debouncedResizeHandler;
  var ellipsizers = [];
  var imgResizers = [];
  var widgetReady = false;
  var overlayEl;
  var widgetScrolled = false;
  var popupWidgetEl;
  var popupWidgetContentEl;

  
  var ROWS;
  var WIDGET_TYPE;
  var RESPONSIVE_TITLE_FONT;
  var HEAD_LINES_COUNT;
  var DESC_LINES_COUNT;
  var CUT_TEXT_UNTIL_THUMBNAIL_BOTTOM;
  var FULL_ITEM_CLICKABLE;
  var PRESERVE_ROWS_QUANTITY;
  var UTM_FROM;
  var UTM_HASH_FROM;
  var SHOW_POS_PERCENT;
  var FIXED_WIDTH;
  var IS_PREVIEW;
  var HORIZONTAL_ALIGN_EL_SELECT;
  var POSITION;
  var CLIENT_SIDE_CROP;
  

  init();

  this.swapRec = swapRec;

  function init() {
    ROWS = widgetParams.rows;
    WIDGET_TYPE = widgetParams.widgetType;
    RESPONSIVE_TITLE_FONT = widgetParams.responsiveTitleFont || false;
    HEAD_LINES_COUNT = widgetParams.headLinesCount || 0;
    DESC_LINES_COUNT = widgetParams.descLinesCount || 0;
    CUT_TEXT_UNTIL_THUMBNAIL_BOTTOM = widgetParams.cutTextUntilThumbnailBottom || false;
    FULL_ITEM_CLICKABLE = widgetParams.clickableItem || false;
    PRESERVE_ROWS_QUANTITY = widgetParams.preserve_rows_quantity || false;
    UTM_FROM = unescapeHTML(widgetParams.utm_from || '');
    UTM_HASH_FROM = unescapeHTML(widgetParams.utm_hash_from || '');
    FIXED_WIDTH = parseFloat(widgetParams.fixedWidth) || null;
    IS_PREVIEW = widgetParams.isPreview || false;
    HORIZONTAL_ALIGN_EL_SELECT = widgetParams.horizontalAlignElSelect || '';
    POSITION = widgetParams.position || '';
    CLIENT_SIDE_CROP = widgetParams.betaClientSideCrop || false;

    anchorEl = d.getElementById(widgetId);

    if (!anchorEl && !noAnchorNeeded) {
      log('relap: no widget anchor in html is found for widget: ' + widgetId + ', exit');
      return;
    }

    el = d.createElement('div');
    el.innerHTML = widgetHTML;

    debugWidget(widgetId, "recommendations_showed", el.getElementsByClassName("js-relap__item").length);
    debugStatus(widgetId, "success", "widget_showed");
    debugEnd(widgetId);

    if (executeOnWidgetScriptLoad) {
      try {
        executeOnWidgetScriptLoad(widgetId);
      } catch(e) {
      }
    }

    if (FIXED_WIDTH) {
      el.style.width = FIXED_WIDTH + 'px';
    }

    switch(WIDGET_TYPE) {
      case 'toster':
      case 'popup':
        handlePopupWidget();
        break;
      case 'plain':
      case 'side':
      case 'inset':
        handleInlineWidget();
        break;
    }

    links = el.getElementsByClassName('js-relap__item-link');

    if (!links.length) {
      log('relap: no js-relap__item-link in html is found for widget: ' + widgetId + ', exit');
      return;
    }

    topContainerEl = el.getElementsByClassName('js-relap__top-container')[0];

    if (!topContainerEl) {
      log('relap: no relap__top-container in html is found for widget: ' + widgetId + ', exit');
      return;
    }

    maxColumnQuantity = parseFloat(topContainerEl.getAttribute('data-relap-max-column-quantity'));
    items = el.getElementsByClassName('js-relap__item');
    fakeItems = el.getElementsByClassName('js-relap__fake-item');

    if (WIDGET_TYPE == 'plain' || 
        WIDGET_TYPE == 'side' ||
        WIDGET_TYPE == 'inset') {
      handleBlockScrolledTo(topContainerEl);
    }

    if (UTM_FROM || UTM_HASH_FROM) {
      addUTMToLinks();
    }

    tryToCreateOverlay();

    for (var i = 0; i < items.length; i++) {
      initItem(items[i]);
    }

    var logoLink = el.getElementsByClassName('js-relap__logo')[0];

    if (logoLink && IS_PREVIEW) {
      logoLink.addEventListener('click', previewClickHandler, false);
    }

    w.addEventListener('resize', resizeHandler, false);

    if (WIDGET_TYPE === 'toster' || WIDGET_TYPE === 'popup'){
      w.addEventListener('scroll', onWindowScroll, false);
    }

    /*событые очистки handler'ов*/
    d.body.addEventListener('destroyPreview', handleClearHandlers, false);

    debouncedOnScrollFunc = debounce(onWindowScrollInternal, 250);
    debouncedResizeHandler = debounce(resizeWidget, 250);

    prepareWidgetBeforeShow();


    function handlePopupWidget() {
      switch (WIDGET_TYPE) {
        case 'toster':
          el.className = 'relap-' + widgetParams.theme + '__popup-container';

          if (widgetParams.shadow) {
            addClassName(el, 'relap-' + widgetParams.theme + '__with-shadow');
          }

          if (widgetParams.presetName === 'tosterHorizontalPlates') {
            addClassName(el, 'relap-' + widgetParams.theme + '__horizontal-toster');
          }

          switch (widgetParams.position) {
            case 'center':
              addClassName(el, 'relap-' + widgetParams.theme + '__pos-center');
            case 'right':
              addClassName(el, 'relap-' + widgetParams.theme + '__pos-right');
              break;
            case 'left':
              addClassName(el, 'relap-' + widgetParams.theme + '__pos-left');
          }

          /*навешиваем анимацию*/
          addClassName(el, 'relap-' + widgetParams.theme + '__animate');

          elParent = d.body;
          elParent.appendChild(el);
          break;
        case 'popup':
          popupWidgetEl = d.createElement('div');
          popupWidgetEl.className = 'relap-' + widgetParams.theme + '__popup-widget-container';

          var bgEl = d.createElement('div');
          bgEl.className = 'relap-' + widgetParams.theme + '__popup-widget-bg';

          popupWidgetContentEl = d.createElement('div');
          popupWidgetContentEl.className = 'relap-' + widgetParams.theme + '__popup-widget-content' +
            ' ' + 'js-relap-popup-widget-content';
          popupWidgetContentEl.style.minWidth = widgetParams.widgetMinWidth + 'px';
          popupWidgetContentEl.style.maxWidth = widgetParams.widgetMaxWidth + 'px';
          popupWidgetContentEl.appendChild(el);

          addClassName(el, 'relap-' + widgetParams.theme + '__popup-widget-content-inner');

          popupWidgetEl.appendChild(bgEl);
          popupWidgetEl.appendChild(popupWidgetContentEl);
          elParent = d.body;
          elParent.appendChild(popupWidgetEl);

          break;
      }

      SHOW_POS_PERCENT = widgetParams.showPosPercent || 100;
    }

    function handleInlineWidget() {
      switch (WIDGET_TYPE) {
        case 'plain':
        case 'side':
        case 'inset':
        default:
          el.className = 'relap-' + widgetParams.theme + '-wrapper';
      }

      var similarPagesScripts = d.getElementsByClassName('relap-sp_' + widgetId);

      for (var i = 0; i < similarPagesScripts.length; i++) {
        if (similarPagesScripts[i].getAttribute('data-init')) continue;
        initScript(similarPagesScripts[i]);
      }

      function initScript(scriptEl) {
        scriptEl.setAttribute('data-init', 1);
        elParent = scriptEl.parentNode;
        elParent.insertBefore(el, scriptEl);
      }
    }

    function prepareWidgetBeforeShow() {
      var preloaderEl;

      if (widgetParams.hasPreloader) {
        preloaderEl = createPreloader();
      }

      hideWidget();

      if (executeOnWidgetPreloaderShow) {
        try {
          executeOnWidgetPreloaderShow(preloaderEl);
        } catch(e) {
        }
      }

      onImagesComplete({
        imgElems: el.getElementsByTagName('img'),
        onComplete: function() {
          showWidget();
          onWidgetReady();
          setTimeout(function() {
            resizeWidget(true);
          }, 500);
          setTimeout(function() {
            resizeWidget(true);
          }, 1000);
        },
        timeout: Infinity
      });

      function createPreloader() {
        var el = d.createElement('div');
        var spinnerEl = d.createElement('span');

        el.className = 'relap-' + widgetParams.theme + '__preloader';
        spinnerEl.className = 'relap-' + widgetParams.theme +
          '__preloader-spinner';

        el.appendChild(spinnerEl);

        return el;
      }

      function hideWidget() {
        el.style.visibility = 'hidden';
        el.style.position = 'absolute';
        el.style.left = '-99999px';

        if (!preloaderEl) return;

        try {
          el.parentNode.insertBefore(preloaderEl, el);
        } catch(e) {
        }
      }

      function showWidget() {
        el.style.visibility = '';
        el.style.position = '';
        el.style.left = '';

        if (!preloaderEl || !preloaderEl.parentNode) return;

        try {
          preloaderEl.parentNode.removeChild(preloaderEl);
        } catch(e) {
        }
      }
    }
  }

  function initItem(item) {
    var links = item.getElementsByClassName('js-relap__item-link');
    var innerLinks = item.getElementsByClassName('js-relap-extended-offer-inner-link');

    for (var i = 0; i < links.length; i++) {
      initLink(links[i]);
    }

    for (var i = 0; i < innerLinks.length; i++) {
      initInnerLink(innerLinks[i]);
    }

    initEllipsizer(item);
    loadExternalScripts(item);
    handleOnLoadStatImages(item);

    function initLink(link) {
      if (IS_PREVIEW) {
        link.addEventListener('click', previewClickHandler, false);
      } else if (!link.hasAttribute('data-init')) {
        link.addEventListener('mouseup', clickHandler, false);
        link.addEventListener('click', clickHandler, false);
        if (link.hasAttribute('data-inline-video')) {
          var inlineVideoIframe = link.querySelector('iframe');
          if (inlineVideoIframe) {
            /* vpaid работает так ненадёжно, что лучше всё спрятать до поры до времени */
            topContainerEl.style.display = 'none';
            function sendMessageToIframe(message) {
              inlineVideoIframe.contentWindow.postMessage(message, inlineVideoIframe.src);
            }
            function sendVastToIframe(storageKey) {
              var vastConfig = sessionStorage.getItem(storageKey);
              if (vastConfig) sendMessageToIframe(vastConfig);
              sessionStorage.removeItem(storageKey);
            }
            function loadVastConfig(vastLoadConfig) {
              vastLoadConfig = JSON.parse(vastLoadConfig);
              startVideoAt = 0.1;
              var extParams = [];
              var extConfigurer = new w.relap.ExtConfigurer({
                cfg: vastLoadConfig,
                extParams: extParams,
                complete: function() {
                  if (!extParams[0]) return; /* vast не загрузился */
                  /* достаём из extParams путь, по которому сохранён полный vast */
                  sendVastToIframe(extParams[0].split('=', 2)[0]);
                }
              });
            }
            /* включить видео в ифрейме, когда он окажется во viewport, и
               послать событие impression при минимальном пересечении */
            var impression_is_sent = false;
            function checkIframeIsVisibleEnough() {
              var intersection = rectsIntersectPercentage(getElementRect(inlineVideoIframe), getViewportRect());
              if (!impression_is_sent && intersection > 0) {
                impression_is_sent = true;
                sendMessageToIframe('impression');
              }
              if (intersection >= 0.25) {
                sendMessageToIframe('play');
              } else {
                sendMessageToIframe('pause');
              }
            }
            function checkWidgetWithinViewport() {
              /* виджет (а именно topContainerEl) с гпмд на данный момент скрыт,
                 поэтому проверяем враппер (который на уровень выше и не скрыт) */
              if ( rectsIntersect(getElementRect(el), getViewportRect()) ) {
                w.removeEventListener('scroll', checkWidgetWithinViewport, false);
                w.removeEventListener('resize', checkWidgetWithinViewport, false);

                var link = findClosestAncestor(inlineVideoIframe, 'a');
                var vastLoadConfig = link.getAttribute('data-vast-load-config');
                if (vastLoadConfig) { /* необычный случай - vast надо загрузить сейчас */
                  link.removeAttribute('data-vast-load-config');
                  loadVastConfig(vastLoadConfig);
                }

                function findClosestAncestor(el, selector) {
                  var limit = 1000;
                  while (limit--) {
                    if (!el) return null;
                    el = el.parentElement;
                    if (matchesSelector(el, selector)) return el;
                  }
                  return null;
                }
              }
            }
            /* http://stackoverflow.com/a/30101330/320345 */
            var matchesSelector = (function(ElementPrototype) {
              var fn = ElementPrototype.matches ||
                       ElementPrototype.matchesSelector ||
                       ElementPrototype.webkitMatchesSelector ||
                       ElementPrototype.mozMatchesSelector ||
                       ElementPrototype.msMatchesSelector ||
                       ElementPrototype.oMatchesSelector ||
                       function (s) {
                         var matches = (this.document || this.ownerDocument).querySelectorAll(s),
                           i = matches.length;
                         while (--i >= 0 && matches.item(i) !== this) {}
                         return i > -1;
                       };
              return function(element, selector) {
                return fn.call(element, selector);
              };
            })(Element.prototype);
            /*
                принять сообщение от ифрейма (и начать проверять, нельзя ли начать
                воспроизведение видео).
            */
            var mouseOverCheckerInterval, mouseIsOverIframe;
            w.addEventListener('message', function (event) {
              if (event.data == 'relap_video_ad_iframe_js_ready') {
                if (link.hasAttribute('data-vast-load-config')) {
                  w.addEventListener('scroll', checkWidgetWithinViewport, false);
                  w.addEventListener('resize', checkWidgetWithinViewport, false);
                  checkWidgetWithinViewport();
                }

                var vastStorageKey = link.getAttribute('data-vast-storage-key');
                if (vastStorageKey) { /* обычный случай - vast уже загружен */
                  sendVastToIframe(vastStorageKey);
                }

              } else if (event.data == 'relap_video_ad_iframe_video_ready') {
                /* для регулировки звука по наведению */
                link.addEventListener('mouseenter', function (event) {
                  mouseIsOverIframe = true;
                  sendMessageToIframe('mouseenter');
                }, false);
                link.addEventListener('mouseleave', function (event) {
                  mouseIsOverIframe = false;
                  sendMessageToIframe('mouseleave');
                }, false);
                /* mouseleave можно и проебать; напишем фолбэк */
                mouseOverCheckerInterval = setInterval(function () {
                  var mouseIsOverIframeFallback = matchesSelector(link, ':hover');
                  if (mouseIsOverIframe && !mouseIsOverIframeFallback) {
                    mouseIsOverIframe = false;
                    sendMessageToIframe('mouseleave');
                  } else if (!mouseIsOverIframe && mouseIsOverIframeFallback) {
                    mouseIsOverIframe = true;
                    sendMessageToIframe('mouseenter');
                  }
                }, 500);
                topContainerEl.style.display = 'block';

                w.addEventListener('scroll', checkIframeIsVisibleEnough, false);
                w.addEventListener('resize', checkIframeIsVisibleEnough, false);
                checkIframeIsVisibleEnough();

              } else if (event.data == 'relap_video_ad_iframe_plays') {
                /*
                  так как сейчас мы останавливаем видео, если перекрытие плеера и окна
                  браузера падает ниже какого-то уровня, то не убираем эти листенеры
                w.removeEventListener('scroll', checkIframeIsVisibleEnough, false);
                w.removeEventListener('resize', checkIframeIsVisibleEnough, false);
                */

              } else if (event.data == 'relap_video_ad_iframe_click') {
                /* 
                  отправляем наши пиксели как обычно через обработчик клика,
                  подсунув фейковый объект эвента
                */
                clickHandler.apply(link, [{ isFake: true, openLinkInNewTab: true }]);
                sendMessageToIframe('zerovolume');

              } else if (event.data == 'relap_vpaid_iframe_click') {
                /*
                  с нашей стороны нужно лишь отправить пиксель event click
                  переход на нужную страницу делает vpaid контейнер
                */
                clickHandler.apply(link, [{ vpaidClick: true }]);
                sendMessageToIframe('zerovolume');

              } else if (event.data == 'relap_video_ad_iframe_close') {
                clearInterval(mouseOverCheckerInterval);
                topContainerEl.parentElement.removeChild(topContainerEl);
                w.removeEventListener('scroll', checkIframeIsVisibleEnough, false);
                w.removeEventListener('resize', checkIframeIsVisibleEnough, false);

              }
            }, false);
            /* дополнительно - добавить проверку в widgetShown; а то ифрейм может
               прислать сообщение о готовности раньше, чем виджет прогрузился
               и занял место на экране */
            var oldExecuteOnWidgetShown = executeOnWidgetShown || function () {};
            executeOnWidgetShown = function (el) {
              if (link.hasAttribute('data-vast-load-config')) {
                checkWidgetWithinViewport();
              }
              checkIframeIsVisibleEnough();
              oldExecuteOnWidgetShown(el);
            };
          } else {
            log('relap: no iframe found in video ad widget');
          }
        }
        
        if (link.hasAttribute('data-inline-video-chain')) {
          function sendMessageToIframe(message) {
            var inlineVideoIframe = link.querySelector('iframe');
            if (!inlineVideoIframe) return;
            inlineVideoIframe.contentWindow.postMessage(message, inlineVideoIframe.src);
          }
          w.addEventListener('message', function (event) {
            if (event.data == 'relap_video_ad_iframe_click') {
              /* 
                отправляем наши пиксели как обычно через обработчик клика,
                подсунув фейковый объект эвента
              */
              clickHandler.apply(link, [{ isFake: true, openLinkInNewTab: true }]);
              sendMessageToIframe('zerovolume');

            } else if (event.data == 'relap_vpaid_iframe_click') {
              /*
                с нашей стороны нужно лишь отправить пиксель event click
                переход на нужную страницу делает vpaid контейнер
              */
              clickHandler.apply(link, [{ vpaidClick: true }]);
              sendMessageToIframe('zerovolume');
            }
          }, false);
        }
        
        if (link.hasAttribute('data-custom-iframe-rec')) {
          w.addEventListener('message', function (event) {
            var parsedData;

            try {
              parsedData = JSON.parse(event.data);
            } catch (e) {
            }

            if (parsedData &&
                parsedData !== null &&
                typeof parsedData === 'object' &&
                parsedData.eventType === 'relapCustomIframeRecClick') {
              var iframeEl = link.querySelector('#' + parsedData.iframeId);

              if (iframeEl) {
                clickHandler.apply(link, [{
                  isFake: true,
                  openLinkInNewTab: link.getAttribute('target') === '_blank',
                }]);
              }
            }
          }, false);
        }

        link.setAttribute('data-init', 'true');
      }
    }

    function initInnerLink(innerLink) {
      if (IS_PREVIEW) {
        innerLink.addEventListener('click', previewClickHandler, false);
      } else if (!innerLink.hasAttribute('data-init')) {
        innerLink.addEventListener('click', handleInnerLinkClick, false);
        innerLink.setAttribute('data-init', 'true');
      }
    }

    function initEllipsizer(item) {
      if (HEAD_LINES_COUNT || CUT_TEXT_UNTIL_THUMBNAIL_BOTTOM) {
        initTitle();
      }

      if (DESC_LINES_COUNT || CUT_TEXT_UNTIL_THUMBNAIL_BOTTOM) {
        initDescription();
      }

      function initTitle() {
        var title = item
          .getElementsByClassName('js-relap__item-title-text')[0];

        if (!title) return;

        var thumbnail = item
          .getElementsByClassName('js-relap__item-thumbnail')[0];

        var ellipsizerOpts = {
          maxLines: HEAD_LINES_COUNT
        };

        if (CUT_TEXT_UNTIL_THUMBNAIL_BOTTOM && thumbnail) {
          ellipsizerOpts.cutUntilEl = thumbnail;
        }

        if (title.getAttribute('data-ellipsizer-hide-overflowing-items') == 'false') {
          ellipsizerOpts.ellipsizeOverflowingItems = false;
        } else {
          ellipsizerOpts.ellipsizeOverflowingItems = true;
        }

        if (title.getAttribute('data-ellipsizer-own-trim') == 'true') {
          ellipsizerOpts.useOwnTrimFunc = true;
        } else {
          ellipsizerOpts.useOwnTrimFunc = false;
        }

        if (title) {
          ellipsizers.push(new Ellipsizer(title, ellipsizerOpts));
        }
      }

      function initDescription() {
        var descr = item
          .getElementsByClassName('js-relap__item-description')[0];

        if (!descr) return;

        var thumbnail = item
          .getElementsByClassName('js-relap__item-thumbnail')[0];

        var ellipsizerOpts = {
          maxLines: DESC_LINES_COUNT
        };

        if (CUT_TEXT_UNTIL_THUMBNAIL_BOTTOM && thumbnail) {
          ellipsizerOpts.cutUntilEl = thumbnail;
        }

        if (descr.getAttribute('data-ellipsizer-hide-overflowing-items') == 'false') {
          ellipsizerOpts.ellipsizeOverflowingItems = false;
        } else {
          ellipsizerOpts.ellipsizeOverflowingItems = true;
        }

        if (descr.getAttribute('data-ellipsizer-own-trim') == 'true') {
          ellipsizerOpts.useOwnTrimFunc = true;
        } else {
          ellipsizerOpts.useOwnTrimFunc = false;
        }

        if (descr) {
          ellipsizers.push(new Ellipsizer(descr, ellipsizerOpts));
        }
      }
    }

    function loadExternalScripts(item) {
      var scriptLoaderElems = item.querySelectorAll('.js-relap-script-loader');

      for (var i = 0; i < scriptLoaderElems.length; i++) {
        var scripts;

        try {
          scripts = JSON.parse(scriptLoaderElems[i].textContent);
        } catch(e) {
        }

        if (!scripts) continue;

        for (var j = 0; j < scripts.length; j++) {
          var script = document.createElement('script');
          script.src = scripts[j];
          scriptLoaderElems[i].parentNode.insertBefore(script, scriptLoaderElems[i]);
        }
      }
    }

    function handleOnLoadStatImages(item) {
      var links = item.getElementsByClassName('js-relap__item-link');

      for (var i = 0; i < links.length; i++) {
        var onLoadAttr = links[i].getAttribute('data-onload-images');
        if (!onLoadAttr) continue;

        try {
          onLoadArr = JSON.parse(onLoadAttr);
          w.relap.onLoadImages.queue(onLoadArr);
        } catch(e) {
        }
      }

      sendOnLoadGA();


      function sendOnLoadGA() {
        if (!gaCfg.onLoad.category || !gaCfg.onLoad.action) return;
        if (gaCfg.onLoad.once && w.relap.gaEventStatus.onLoad) return;

        w.relap.gaEventStatus.onLoad = true;

        onFuncReady({
          funcName: 'ga',
          args: ['send', {
            'hitType': 'event',
            'eventCategory': gaCfg.onLoad.category,
            'eventAction': gaCfg.onLoad.action,
            'eventLabel': gaCfg.onLoad.label,
            'hitCallback': function() {
              log('ga onLoad sent success!!!');
            }
          }],
          onError: function() {
            log('ga onLoad failed because func is not found for id: ' + widgetId);
          }
        });
      }
    }
  }

  function handleBlockScrolledTo(block) {
    if (!block) return;

    w.addEventListener('scroll', checkBlockScrolledTo, false);
    w.addEventListener('resize', checkBlockScrolledTo, false);
    checkBlockScrolledTo();
  }

  function checkBlockScrolledTo() {
    if (!widgetReady) return;
    if (WIDGET_TYPE == 'toster' || WIDGET_TYPE == 'popup') return;

    try {
      var recGroup = topContainerEl.getAttribute('data');

      if (!rectsIntersect(getViewportRect(), getElementRect(topContainerEl))) return;

      if (!widgetScrolled) { handleWidgetShown() }
      widgetScrolled = true;
      var platesWithOnShow = 0, platesWithOnShowShown = 0, linksSize = links.length, onShowImages = [];
      for (var i = 0; i < linksSize; i++) {
        /*log('checkBlockScrolledTo, link', i);*/
        var link = links[i];
        var onShowAttr = link.getAttribute('data-onshow-images');
        var isAd = link.hasAttribute('data-ad-link');
        var isExchange = link.hasAttribute('data-exchange-link');
        if (onShowAttr || isAd || isExchange) {
          platesWithOnShow++;
          if (link.hasAttribute('data-is-shown')) { platesWithOnShowShown++; }
          else if (rectsIntersect(getViewportRect(), getElementRect(link))) {
            link.setAttribute('data-is-shown', 1);
            platesWithOnShowShown++;
            if (onShowAttr) {
              try {
                var o = JSON.parse(onShowAttr);
                onShowImages = onShowImages.concat(o);
              } catch(e){};
            }
            if (isAd) { onShowImages.push(makeImpPix(link)) }
            if (isExchange) { onShowImages.push(makeExchangePix(link)) }
            /*log('    rectsIntersect, onShowImages so far', onShowImages);*/
          }
        } else { /* nothing */ }
      }
      if (onShowImages.length > 0) { w.relap.onShowImages.queue(onShowImages); }
      /*log('checkBlockScrolledTo ended, platesWithOnShowShown and platesWithOnShow is', platesWithOnShowShown, platesWithOnShow);*/
      if (platesWithOnShowShown >= platesWithOnShow) {
        w.removeEventListener('scroll', checkBlockScrolledTo, false);
        w.removeEventListener('resize', checkBlockScrolledTo, false);
      }
    } catch(e) { log(e) }
  }

  function handleWidgetShown() {
    var recGroup = topContainerEl.getAttribute('data');

    if (!recGroup) return;

    log('widget shown: ' + WIDGET_TYPE + ', id: ' + widgetId);
    topContainerEl.removeAttribute('data');

    var onShowImages = [];
    if (WIDGET_TYPE == 'toster' || WIDGET_TYPE == 'popup') {
      for (var i = 0; i < links.length; i++) {
        var onShowAttr = links[i].getAttribute('data-onshow-images');
        if (onShowAttr) {
          try {
            var o = JSON.parse(onShowAttr);
            onShowImages = onShowImages.concat(o);
          } catch(e) {};
        }
        if (links[i].hasAttribute('data-ad-link')) {
          onShowImages.push(makeImpPix(links[i]));
        }
        if (links[i].hasAttribute('data-exchange-link')) {
          onShowImages.push(makeExchangePix(links[i]));
        }
      }
    }
    onShowImages.push({ src: viewPixelSrc, timeout: 1000 });
    w.relap.onShowImages.queue(onShowImages);

    if (executeOnWidgetShown) {
      try {
        executeOnWidgetShown(el);
      } catch(e) {
      }
    }
    sendOnShowGA();

    function sendOnShowGA() {
      if (!gaCfg.onShow.category || !gaCfg.onShow.action) return;
      if (gaCfg.onShow.once && w.relap.gaEventStatus.onShow) return;

      w.relap.gaEventStatus.onShow = true;

      onFuncReady({
        funcName: 'ga',
        args: ['send', {
          'hitType': 'event',
          'eventCategory': gaCfg.onShow.category,
          'eventAction': gaCfg.onShow.action,
          'eventLabel': gaCfg.onShow.label,
          'hitCallback': function() {
            log('ga onShow sent success!!!');
          }
        }],
        onError: function() {
          log('ga onShow failed because func is not found for id: ' + widgetId);
        }
      });
    }
  }

  function makeImpPix (link) {
    return {
      "src": "https://relap.io/api/v1/pixel.gif?event=imp"+
        '&r='+encodeURIComponent(link.getAttribute('data'))+
        '&'+pixelSecretSessionParamName+'='+encodeURIComponent(pixelSecretSessionParam),
      "timeout": 1000
    };
  }
  function makeExchangePix (link) {
    return {
      "src": "https://relap.io/api/v1/pixel.gif?event=exchange_view"+
        '&r='+encodeURIComponent(link.getAttribute('data'))+
        '&'+pixelSecretSessionParamName+'='+encodeURIComponent(pixelSecretSessionParam),
      "timeout": 1000
    };
  }

  /* https://gist.github.com/scottjehl/2051999 */
  var _viewportSize = null;
  function calcViewportSize() {
    var test = document.createElement( "div" );
    test.style.cssText = "position: fixed;top: 0;left: 0;bottom: 0;right: 0;";
    d.documentElement.insertBefore(test, d.documentElement.firstChild);
    _viewportSize = { width: test.offsetWidth, height: test.offsetHeight };
    d.documentElement.removeChild(test);
    return _viewportSize;
  }
  w.addEventListener('resize', calcViewportSize, false);
  function getViewportRect() {
    var x = getDocScrollLeft();
    var y = getDocScrollTop();
    var size = _viewportSize || calcViewportSize();
    return [x, y, x+size.width, y+size.height];
  }

  function getElementRect(element) {
    var viewport = getViewportRect();
    var rect = element.getBoundingClientRect(); /* relative to viewport */
    return [viewport[0] + rect.left, viewport[1] + rect.top, viewport[0] + rect.right, viewport[1] + rect.bottom];
  }

  function rectsIntersect(a, b) {
    return a[0] < b[2] && a[2] > b[0] && a[1] < b[3] && a[3] > b[1];
  }

  /* на сколько процентов своей площади первый прямоугольник (small) попадает во второй (big) */
  function rectsIntersectPercentage(small, big) {
    var x_overlap = Math.max(0, Math.min(small[2], big[2]) - Math.max(small[0], big[0]));
    var y_overlap = Math.max(0, Math.min(small[3], big[3]) - Math.max(small[1], big[1]));
    return (x_overlap * y_overlap) / ( (small[2]-small[0]) * (small[3]-small[1]) );
  }

  function previewClickHandler(event) {
    event.preventDefault();
  }

  function createOverlayClickHandler(linkEl, overlayEl) {
    return function(event) {
      event.isFake = true;
      event.openLinkInNewTab = true;

      clickHandler.call(linkEl, event);
      setTimeout(function() {
        d.body.removeChild(overlayEl);
      }, 0);
    };
  }

  function clickHandler(event) {
    var self = this;
    var href = this.getAttribute('href');

    if (href === 'javascript:void(0)') {
        return;
    }

    var sbrid = this.getAttribute('data');
    var position = this.getAttribute('data-position');
    var forceOpenLinkInNewTab = event.isFake && event.openLinkInNewTab;
    var eType = event.type;
    var which = event.which;
    var ctrlPushed = event.ctrlKey || event.metaKey;
    var videoSrc = this.getAttribute('data-link-video');
    var seedrSID = this.getAttribute('data-seedr-sid');
    var isTargetBlank = this.getAttribute('target') === '_blank';
    var isAd = this.getAttribute('data-ad-link');
    var onClickAttr = this.getAttribute('data-onclick-images');

    /* клик на видео в vpaid контейнере */
    if (event.vpaidClick) {
        sendClick();
        return;
    }
    if (forceOpenLinkInNewTab) {
      if (w.open(href)) {
        sendClick();
      } else {
        sendClick(true);
      }
      return;
    }

    switch(eType) {
      case 'mouseup':
        if (which == 2) {
          sendClick();
        }
        break;
      case 'click':
        if (isTargetBlank || ctrlPushed) {
          sendClick();
          break;
        }

        if (which == 1) {
          event.preventDefault();

          if (seedrSID || videoSrc) {
            sendClick();
            createVideoPopup();
          } else {
            sendClick(true);
          }
        }
        break;
    }

    function sendClick(locationChange) {
      if (!href) return;

      if (sbrid) {
        self.removeAttribute('data');
        removeItemSbrid(self);

        if (executeOnItemClick) {
          try {
            executeOnItemClick(self, el);
          } catch(e) {
          }
        }

        sendClickToServer(locationChange);

      } else if (locationChange) {
          w.location = href;
      }

      function removeItemSbrid(link) {
        var parentNode = link.parentNode;

        while (parentNode) {

          if (hasClassName(parentNode, 'js-relap__item') ||
          hasClassName(parentNode, 'js-relap__top-container') ||
          parentNode === d.body) {
            break;
          }

          parentNode = parentNode.parentNode;
        }

        if (!hasClassName(parentNode, 'js-relap__item')) return;

        var links = parentNode.getElementsByClassName('js-relap__item-link');
        for (var i = 0; i < links.length; i++) {
          links[i].removeAttribute('data');
        }

        function hasClassName(el, className) {
          if (!el) return false;
          var elClassName = el.className ? el.className : ' ';
          var classes = elClassName.split(' ');

          for (var i = 0; i < classes.length; i++) {
            if (classes[i] == className) return true;
          }

          return false;
        }
      }

      function sendClickToServer(locationChange) {
        var requestStatus = {
          gaComplete: false,
          imgStatComplete: false
        };

        var params = {};
        params.event = 'click';
        params[pixelClickParamName] = sbrid;
        params.url = href;
        params.referrer = w.location.href;
        params[pixelSecretSessionParamName] = pixelSecretSessionParam;

        var finalize = (function(location, locationShouldBeChanged) {
          return function() {
            if (!requestStatus.gaComplete ||
                !requestStatus.imgStatComplete) {
              return;
            }

            log('all stat on click complete');
            if (isAd && widgetParams.presetName !== 'insetFullPlates') {
              
              setTimeout(function() {
                handleRecSwap(position);
              }, 500);
            }

            if (locationShouldBeChanged) {
              w.location = location;
            }
          }
        })(href, locationChange);

        sendOnClickGA();

        try {
          var onClickArr = JSON.parse(onClickAttr);
        } catch(e) {
          onClickArr = [];
        }

        onClickArr.push({
          src: buildRequestURL(pixelSrcStart, params),
          timeout: 1000
        });

        loadImages({
          imagesArr: onClickArr,
          onComplete: function() {
            log('images on click complete');
            requestStatus.imgStatComplete = true;
            finalize();
          }
        });

        function sendOnClickGA() {
          var timeoutId;
          var gaObj;

          if (!gaCfg.onClick.category || !gaCfg.onClick.action) {
            requestStatus.gaComplete = true;
            finalize();
            return;
          }

          if (gaCfg.onClick.once && w.relap.gaEventStatus.onClick) {
            requestStatus.gaComplete = true;
            finalize();
            return;
          }

          w.relap.gaEventStatus.onClick = true;

          timeoutId = setTimeout(function() {
            requestStatus.gaComplete = true;
            finalize();
          }, 1000);

          gaObj = {
            'hitType': 'event',
            'eventCategory': gaCfg.onClick.category,
            'eventAction': gaCfg.onClick.action,
            'eventLabel': gaCfg.onClick.label,
            'hitCallback': function() {
              log('ga onClick sent success!!!');
              clearTimeout(timeoutId);
              requestStatus.gaComplete = true;
              finalize();
            }
          };

          if (gaCfg.onClick.valueType === 'position') {
            gaObj.eventValue = position;
          }

          onFuncReady({
            funcName: 'ga',
            args: ['send', gaObj],
            onError: function() {
              log('ga onLoad failed because func is not found for id: ' + widgetId);
            }
          });
        }

        function loadImages(opt) {
          var imagesArr = opt.imagesArr;
          var onComplete = opt.onComplete;
          
          var firedAway = false;

          for (var i = 0; i < imagesArr.length; i++) {
            loadImage(imagesArr[i]);
          }

          function loadImage(item) {
            var timeout = item.timeout || 500;

            var timeoutId = setTimeout(function() {
              log('extStat img completed by timeout: ' + item.src);
              item.loadComplete = true;
              tryToComplete();
            }, timeout);

            var img = new Image();
            img.onload = img.onerror = function() {
              log('extStat img loaded/error: ' + item.src);
              clearTimeout(timeoutId);
              item.loadComplete = true;
              tryToComplete();
            };

            img.src = item.src;
          }

          function tryToComplete() {
            if (!checkAllImagesComplete() || firedAway) return;

            firedAway = true;

            if (onComplete) onComplete();

            function checkAllImagesComplete() {
              for (var i = 0; i < imagesArr.length; i++) {
                if (!imagesArr[i].loadComplete) return false;
              }

              return true;
            }
          }
        }
      }
    }

    function handleRecSwap(position) {
      event.preventDefault();
      var URLStart = 'https://relap.io/api/v6/similar_pages_ritem_jsonp.js';
      var script = d.createElement('script');
      var params = {
        seed: seed,
        widget_id: widgetId,
        rgid: rgid,
        onlyAdsNeeded: 1,
        url: url,
        limit: 1,
        callback: 'window.relap.swapRec',
        rec_position: position,
        widget_instance_id: widgetInstanceId,
      };
      params[pixelSecretSessionParamName] = pixelSecretSessionParam;

      var payload = merge(queryParams, params);
      script.src = buildRecSrc(URLStart, payload);
      d.body.appendChild(script);
      d.body.removeChild(script);

      function merge(obj1, obj2) {
        var obj = {};

        for (var key in obj1) {
          if (!obj1.hasOwnProperty(key)) continue;
          obj[key] = obj1[key];
        }

        for (var key in obj2) {
          if (!obj2.hasOwnProperty(key)) continue;
          obj[key] = obj2[key];
        }

        return obj;
      }

      function buildRecSrc(URLStart, payload) {
        var paramStr = [];
        var string = '';

        for (var key in payload) {
          paramStr.push(key + '=' + encodeURIComponent(payload[key]));
        }

        var url = URLStart + '?' + paramStr.join('&');

        return url;
      }
    }

    function createVideoPopup() {
      var popupEl = d.createElement('div');
      popupEl.className = 'relap-' + widgetParams.theme + '__popup-centered';
      popupEl.innerHTML = '<div class=\"relap-' + widgetParams.theme +
        '__popup-centered__bg js-relap__popup-bg\"></div>' +
      '<div class=\"relap-' + widgetParams.theme + '__popup-centered__content\">' +
        '<div class=\"relap-' + widgetParams.theme + '__popup-centered__content__close-link ' +
        'js-relap__popup-close\"></div>' +
        '<div class=\"relap-' + widgetParams.theme +
          '__popup-centered__content__video-iframe-container' +
          ' js-relap__popup-video-container\">' +
        '</div>' +
      '</div>';

      d.body.appendChild(popupEl);

      popupEl.addEventListener('click', onVideoPopupCloseClick, false);

      if (seedrSID) {
        createSeedrPlayer(seedrSID);
        return;
      }

      if (videoSrc) {
        createVideoIframe(videoSrc);
        return;
      }

      function onVideoPopupCloseClick(e) {
        var target = e.target;

        while (target != this) {
          if (hasClassName(target, 'js-relap__popup-bg') ||
              hasClassName(target, 'js-relap__popup-close')) {
            destroyVideoPopup();
          }

          target = target.parentNode;
        }

        function destroyVideoPopup() {
          popupEl.removeEventListener('click', onVideoPopupCloseClick, false);
          d.body.removeChild(popupEl);
        }
      }

      function createSeedrPlayer(seedrSID) {
        var videoContainerEl = popupEl
          .querySelector('.js-relap__popup-video-container');

        if (!videoContainerEl) return;

        var seedrPlayerContainerEl = d.createElement('div');
        seedrPlayerContainerEl.id = '___seedrPlayerContainer';
        seedrPlayerContainerEl.setAttribute('data-gid', seedrSID);

        videoContainerEl.appendChild(seedrPlayerContainerEl);
        initPlayer();

        function initPlayer() {
          w.seedrPlayer = {
            surl: w.top.location.href
          };

          w.onSeedrPlayerAPIPlay = function() {
            
            var img = new Image();
            img.src = href;
          };

          (function (a, b, c, d, e, f, g, h) {
            g = b.createElement(c);
            g.src = d;
            g.type = "application/javascript";
            g.async = !0;
            h = b.getElementsByTagName(c)[0];
            h.parentNode.insertBefore(g, h);
            a[f] = [];
            a[e] = function () {
              a[f].push(Array.prototype.slice.apply(arguments));
            }
          }) (w, d, "script", (d.location.protocol === "https:" ? "https:" : "http:") + "//seedr.com/js/seedr-player.min.js", "SeedrPlayer", "seedrInit");
        }
      }

      function createVideoIframe(iframeSrc) {
        var videoContainerEl = popupEl
          .querySelector('.js-relap__popup-video-container');

        if (!videoContainerEl) return;

        var iframeEl = d.createElement('iframe');
        iframeEl.src = iframeSrc;
        iframeEl.setAttribute('frameborder', 0);
        iframeEl.setAttribute('webkitallowfullscreen', '');
        iframeEl.setAttribute('mozallowfullscreen', '');
        iframeEl.setAttribute('allowfullscreen', '');
        addClassName(iframeEl, 'relap-' + widgetParams.theme +
          '__popup-centered__content__video-iframe');
        addClassName(iframeEl, 'js-relap__popup-video-iframe');

        videoContainerEl.appendChild(iframeEl);
      }
    }
  }

  function swapRec(opts) {
    var recHTML = opts.recHTML;
    var recPosition = opts.recPosition;

    var tempEl = d.createElement('div');
    tempEl.innerHTML = recHTML;
    var newItem = tempEl.getElementsByClassName('js-relap__item')[0];

    if (!newItem) return;

    var images = newItem.getElementsByTagName('img');
    for (var i = 0; i < images.length; i++) {
      images[i].onload = onImageLoad;
      images[i].onerror = onImageLoad;
    }

    var newLinks = newItem.getElementsByClassName('js-relap__item-link');
    for (var i = 0; i < newLinks.length; i++) {
      newLinks[i].setAttribute('data-position', recPosition);
    }

    var oldElem;

    for (var i = 0; i < items.length; i++) {
      if (i != (recPosition - 1)) continue;
      oldElem = items[i];
      break;
    }

    if (!oldElem) return;

    oldElem.parentElement.replaceChild(newItem, oldElem);

    initItem(newItem);
    items = el.getElementsByClassName('js-relap__item');
    links = el.getElementsByClassName('js-relap__item-link');
    resizeWidget(true);
    handleOnShowPixels(newItem);

    function onImageLoad() {
      resizeWidget(true);
    }

    function handleOnShowPixels(item) {
      var links = item.getElementsByClassName('js-relap__item-link');
      if (!links.length) return;
      var onShowImages = [];

      for (var i = 0; i < links.length; i++) {
        var link = links[i];
        var onShowAttr = link.getAttribute('data-onshow-images');
        var isAd = link.hasAttribute('data-ad-link');
        var isExchange = link.hasAttribute('data-exchange-link');

        if (onShowAttr || isAd || isExchange) {
          link.setAttribute('data-is-shown', 1);

          if (onShowAttr) {
            try {
              var o = JSON.parse(onShowAttr);
              onShowImages = onShowImages.concat(o);
            } catch(e){};
          }
          if (isAd) { onShowImages.push(makeImpPix(link)) }
          if (isExchange) { onShowImages.push(makeExchangePix(link)) }
        }
        if (onShowImages.length > 0) { w.relap.onShowImages.queue(onShowImages); }
      }
    }
  }

  function unescapeHTML(str) {
    if (!str) return;

    var div = document.createElement('div');
    div.innerHTML = str;
    return div.firstChild.data;
  }

  function tryToCreateOverlay() {
    overlayEl = document.getElementById('js-relap-overlay');
    if (!overlayEl) createOverlay();
    addHandlers();

    function createOverlay() {
      for (var i = 0; i < items.length; i++) {
        if (!hasClassName(items[i], 'js-relap__with-overlay')) continue;

        overlayEl = document.createElement('div');
        overlayEl.id = 'js-relap-overlay';
        overlayEl.style.position = 'fixed';
        overlayEl.style.top = '0';
        overlayEl.style.bottom = '0';
        overlayEl.style.left = '0';
        overlayEl.style.right = '0';
        overlayEl.style.zIndex = '10000000';
        document.body.appendChild(overlayEl);
        break;
      }
    }

    function addHandlers() {
      if (!overlayEl) return;

      for (var i = 0; i < items.length; i++) {
        if (!hasClassName(items[i], 'js-relap__with-overlay')) continue;

        var linkEl = items[i].querySelector('.js-relap__item-link');
        if (!linkEl) continue;

        if (overlayEl.getAttribute('data-has-handler')) return;

        overlayEl.addEventListener('click', createOverlayClickHandler(linkEl, overlayEl));
        overlayEl.setAttribute('data-has-handler', true);
      }
    }
  }

  function addUTMToLinks() {
    var useHash = false;
    var from = UTM_FROM;

    if (UTM_HASH_FROM) {
      useHash = true;
      from = UTM_HASH_FROM;
    }

    for (var i = 0; i < links.length; i++) {
      var href = links[i].getAttribute('href');
      var appex;

      if (useHash) {
        appex = '#';
      } else {
        appex = '?';

        if (~href.indexOf('?')) {
          appex = '&';
        }
      }

      href += appex + from;
      links[i].setAttribute('href', href);
    }
  }

  function resizeHandler() {
    debouncedResizeHandler();
  }

  function handleClearHandlers(event) {
    if (widgetId !== 'preview') return;

    w.removeEventListener('resize', resizeHandler, false);
    w.removeEventListener('scroll', onWindowScroll, false);
    d.body.removeEventListener('destroyPreview', handleClearHandlers, false);
  }

  function onWidgetReady() {
    widgetReady = true;
    resizeWidget(true);
    initImgResizers();
    resizeWidget(true);

    if (executeOnWidgetReady) {
      try {
        executeOnWidgetReady(el);
      } catch(e) {
      }
    }

    if (WIDGET_TYPE == 'toster' || WIDGET_TYPE === 'popup') {
      onWindowScroll();
    } else {
      checkBlockScrolledTo();
    }

    function initImgResizers() {
      if (!CLIENT_SIDE_CROP) return;

      var imgElems = el.getElementsByClassName('js-relap__item-thumbnail__img');

      for (var i = 0; i < imgElems.length; i++) {
        imgResizers.push(new ImgResizer({
          img: imgElems[i],
          fullWidth: true
        }));
      }
    }
  }

  function resizeWidget(forced) {
    if (!elParent) return;

    var windowMinWidth = widgetParams.windowMinWidth;
    var windowMaxWidth = widgetParams.windowMaxWidth;
    var windowWidth = w.innerWidth;
    var windowHeight = w.innerHeight;
    var shouldBeHidden = false;

    if (!IS_PREVIEW &&
        ((windowMinWidth && windowWidth < windowMinWidth) ||
        (windowMaxWidth && windowWidth > windowMaxWidth) ||
        (WIDGET_TYPE == 'toster' &&
        (el.offsetHeight > windowHeight || el.offsetWidth > windowWidth)))) {
      shouldBeHidden = true;
    }

    if (shouldBeHidden) {
      if (WIDGET_TYPE == 'toster') {
        el.style.visibility = 'hidden';
      } else {
        el.style.display = 'none';
        return;
      }
    } else {
      if (WIDGET_TYPE == 'toster') {
        el.style.visibility = '';
      } else {
        el.style.display = '';
      }
    }

    elParentNewWidth = elParent.clientWidth;

    if (elParentWidth === elParentNewWidth && !forced) return;

    elParentWidth = elParentNewWidth;

    var rowLength = getRowLength();

    setWidgetWidth();

    if (RESPONSIVE_TITLE_FONT) {
      setFontSize();
    }

    if (FULL_ITEM_CLICKABLE) {
      removeItemMinHeight();
    }

    refreshImgResizers();
    cutTextBlocks();

    if (widgetParams.theme === 'default' &&
        widgetParams.presetName === 'insetFullPlates') {
      var itemEl = el.querySelector('.js-relap__item');

      if (itemEl &&
          hasClassName(itemEl, 'relap-' + widgetParams.theme + '__wide-inset-mode-adaptive') &&
          !hasClassName(itemEl, 'js-relap__custom-wide-inset-rec-item') &&
          !hasClassName(topContainerEl, 'relap-' + widgetParams.theme + '__extended-cols')) {
        handleAdaptiveWideInset();
      }

      if (itemEl &&
          hasClassName(itemEl, 'relap-' + widgetParams.theme + '__wide-inset-mode-vertical') &&
          !hasClassName(itemEl, 'js-relap__custom-wide-inset-rec-item') &&
          !hasClassName(topContainerEl, 'relap-' + widgetParams.theme + '__extended-cols')) {
        handleVerticalWideInset();
      }
    }

    if (FULL_ITEM_CLICKABLE) {
      setItemMinHeight();
    }

    if (WIDGET_TYPE == 'toster') {
      alignElHorizontally();
    }

    function setWidgetWidth() {
      var maxColumnQuantity = parseFloat(topContainerEl.getAttribute('data-relap-max-column-quantity'));
      var orphans = 0;
      var fakeItemsNeeded = 0;

      setColumnQuantity(maxColumnQuantity);
      rowLength = getRowLength();
      orphans = items.length % rowLength;

      if (rowLength > maxColumnQuantity) return;

      setColumnQuantity(rowLength);

      if (orphans && !PRESERVE_ROWS_QUANTITY) {
        fakeItemsNeeded = rowLength - orphans;
      }

      hideAllFakeItems();
      showFakeItemsNeeded();

      if (PRESERVE_ROWS_QUANTITY) hideOtherRows();

      function setColumnQuantity(num) {
        topContainerEl.setAttribute('data-column-quantity', num);
        removePreviousClasses();
        addClassName(topContainerEl, 'relap-' + widgetParams.theme + '-column-quantity-' + num);

        function removePreviousClasses() {
          var classes = topContainerEl.className.split(' ');
          var classesToRemove = [];

          for (var i = 0; i < classes.length; i++) {
            if (~classes[i].indexOf('relap-' + widgetParams.theme + '-column-quantity-')) {
              classesToRemove.push(classes[i]);
            }
          }

          for (var i = 0; i < classesToRemove.length; i++) {
            removeClassName(topContainerEl, classesToRemove[i]);
          }
        }
      }

      function hideOtherRows() {
        for (var i = 0; i < items.length; i++) {
          if (i < rowLength * ROWS) continue;
          items[i].style.display = 'none';
        }
      }

      function hideAllFakeItems() {
        for (var i = 0; i < fakeItems.length; i++) {
          fakeItems[i].style.display = 'none';
        }
      }

      function showFakeItemsNeeded() {
        for (var i = 0; i < fakeItemsNeeded; i++) {
          fakeItems[i].style.display = 'inline-block';
        }
      }
    }

    function getRowLength() {
      if (PRESERVE_ROWS_QUANTITY) showAllItems();

      var firstOffsetTop;
      for (var i = 0; i < items.length; i++) {
        var itemOffsetTop = items[i].getBoundingClientRect().top;
        if (i == 0) firstOffsetTop = itemOffsetTop;
        if (firstOffsetTop != itemOffsetTop) {
          break;
        }
      }

      return i;

      function showAllItems() {
        for (var i = 0; i < items.length; i++) {
          items[i].style.display = '';
        }
      }
    }

    function removeItemMinHeight() {
      for (var i = 0; i < links.length; i++) {
        links[i].style.minHeight = '';
      }
    }

    function setItemMinHeight() {
      var maxHeight = 0;
      var maxHeightArr = [];

      for (var i = 0; i < links.length; i++) {
        links[i].style.minHeight = '';
      }

      for (var i = 0; i < links.length; i++) {
        if (i && !(i % rowLength)) {
          maxHeightArr.push(maxHeight);
          maxHeight = 0;
        }

        if (links[i].clientHeight > maxHeight) {
          maxHeight = links[i].clientHeight;
        }
      }

      maxHeightArr.push(maxHeight);

      for (var j = 0, rowIndex = 0; j < links.length; j++) {
        var compStyles = getComputedStyle(links[j]);

        if (j && !(j % rowLength)) rowIndex++;

        links[j].style.minHeight = (maxHeightArr[rowIndex]) + 'px';
      }
    }

    function setFontSize() {
      var titleElems = el.getElementsByClassName('js-relap__item-title');
      var parentWidth = titleElems[0].parentNode.clientWidth;
      var fontSize = parseFloat(topContainerEl.getAttribute('data-relap-percent-font-size')) / 100;
      var minFontSizeInPx = parseFloat(topContainerEl.getAttribute('data-relap-px-min-font-size'));

      for (var i = 0; i < titleElems.length; i++) {

        var fontSizeInPx = parentWidth * fontSize;

        if (fontSizeInPx < minFontSizeInPx) {
          fontSizeInPx = minFontSizeInPx;
        }

        titleElems[i].style.fontSize = fontSizeInPx + 'px';
      }
    }

    function alignElHorizontally() {
      if (!HORIZONTAL_ALIGN_EL_SELECT) return;

      var alignEl = d.querySelector(HORIZONTAL_ALIGN_EL_SELECT);
      if (!alignEl) return;

      var alignElCoords = alignEl.getBoundingClientRect();

      switch(POSITION) {
        case 'left':
          el.style.left = alignElCoords.left + 'px';
          break;
        case 'right':
          var windowWidth = d.documentElement.clientWidth;
          el.style.right = windowWidth - alignElCoords.right + 'px';
          break;
      }
    }

    function handleAdaptiveWideInset() {
      var imgEl = el.querySelector('.js-relap__item-thumbnail__img');
      if (!imgEl) return;

      var elWidth = el.clientWidth;
      var imgWidth = imgEl.naturalWidth;
      var extendedOfferEl = el.querySelector('.js-relap__extended-offer');
      var itemTitleEl = el.querySelector('.js-relap__item-title');
      var contentWidth;

      resetAdaptiveClasses();

      if (imgWidth < elWidth) {
        makeStrings();

        if (imgWidth > 300) {
          makeTargetMailStrings();

          if (extendedOfferEl && extendedOfferEl.clientWidth < 250) {
            setThumbnailSizeInStrings(imgWidth);
          }
        } else {
          setThumbnailSizeInStrings(imgWidth);
        }

        if (itemTitleEl) contentWidth = itemTitleEl.clientWidth;
        if (extendedOfferEl) contentWidth = extendedOfferEl.clientWidth;

        if (contentWidth < 300) {
          resetAdaptiveClasses();

          if (imgEl.clientWidth > imgWidth) {
            handleVerticalWideInset();
          }
        }
      }

      if (!extendedOfferEl) return;
      handleExtendedOffer(extendedOfferEl.clientWidth);

      function resetAdaptiveClasses() {
        el.style.width = '';
        unmakeStrings();
        unmakeTargetMailStrings();
        removeImgSizeClass();
      }

      function makeStrings() {
        addClassName(topContainerEl, 'relap-' + widgetParams.theme + '__view-strings');
        addClassName(topContainerEl, 'relap-' + widgetParams.theme + '__top-container--adaptive-wide-inset');
      }

      function unmakeStrings() {
        removeClassName(topContainerEl, 'relap-' + widgetParams.theme + '__view-strings');
        removeClassName(topContainerEl, 'relap-' + widgetParams.theme + '__top-container--adaptive-wide-inset');
      }

      function setThumbnailSizeInStrings(imgWidth) {
        unmakeTargetMailStrings();

        if (imgWidth > 200) {
          setStringsThumbnailSize(6);
        } else if (imgWidth > 152) {
          setStringsThumbnailSize(5);
        } else if (imgWidth > 116) {
          setStringsThumbnailSize(4);
        } else if (imgWidth > 88) {
          setStringsThumbnailSize(3);
        } else if (imgWidth > 66) {
          setStringsThumbnailSize(2);
        } else {
          setStringsThumbnailSize(1);
        }
      }

      function makeTargetMailStrings() {
        addClassName(topContainerEl, 'relap-' + widgetParams.theme + '__top-container--target-mail');
        addClassName(topContainerEl, 'relap-' + widgetParams.theme + '__top-container--string-item-vertical');
      }

      function unmakeTargetMailStrings() {
        removeClassName(topContainerEl, 'relap-' + widgetParams.theme + '__top-container--target-mail');
        removeClassName(topContainerEl, 'relap-' + widgetParams.theme + '__top-container--string-item-vertical');
      }

      function setStringsThumbnailSize(size) {
        removeImgSizeClass();
        addClassName(topContainerEl, 'relap-' + widgetParams.theme + '_img-size-' + size);
      }
      
      function removeImgSizeClass() {
        for (var i = 1; i <= 6; i++) {
          removeClassName(topContainerEl, 'relap-' + widgetParams.theme + '_img-size-' + i);
        }
      }
    }

    function handleVerticalWideInset() {
      el.style.width = '';

      var imgEl = el.querySelector('.js-relap__item-thumbnail__img');
      if (!imgEl) return;

      var imgWidth = imgEl.naturalWidth;
      var elWidth = el.clientWidth;

      var itemInner = el.querySelector('.js-relap__item-inner');
      var itemInnerComputedStyle = itemInner ? getComputedStyle(itemInner) : {};
      var paddingLeft = isNaN(parseInt(itemInnerComputedStyle.paddingLeft)) ? 0 : parseInt(itemInnerComputedStyle.paddingLeft);
      var paddingRight = isNaN(parseInt(itemInnerComputedStyle.paddingRight)) ? 0 : parseInt(itemInnerComputedStyle.paddingRight);
      var padding = paddingLeft + paddingRight;

      var item = el.querySelector('.js-relap__item');
      var itemComputedStyle = item ? getComputedStyle(item) : {};
      var minWidth = isNaN(parseInt(itemComputedStyle.minWidth)) ? 0 : parseInt(itemComputedStyle.minWidth);

      var newElWidth;

      if (elWidth > (imgWidth + padding)) {
        newElWidth = imgWidth + padding + 'px';
      }

      if (imgWidth + padding < minWidth - padding) {
        newElWidth = minWidth + 'px';
      }

      if (newElWidth) el.style.width = newElWidth;

      var extendedOfferEl = el.querySelector('.js-relap__extended-offer');
      if (!extendedOfferEl) return;
      handleExtendedOffer(extendedOfferEl.clientWidth);
    }

    function handleExtendedOffer(extendedOfferElWidth) {
      if (extendedOfferElWidth < 500) {
        addClassName(topContainerEl, 'relap-' + widgetParams.theme + '__top-container--string-item-vertical');
      } else {
        removeClassName(topContainerEl, 'relap-' + widgetParams.theme + '__top-container--string-item-vertical');
      }
    }
  }

  function refreshImgResizers() {
    for (var i = 0; i < imgResizers.length; i++) {
      imgResizers[i].update();
    }
  }

  function cutTextBlocks(){
    for (var i = 0; i < ellipsizers.length; i++) {
      ellipsizers[i].update();
    }
  }

  function onWindowScroll(e) {
    debouncedOnScrollFunc();
  }

  function debounce(func, wait, immediate) {
    var timeoutId;

    return function() {
      var context = this, args = arguments;

      if (timeoutId) {
        return;
      }

      if (immediate) {
        execute();
        return;
      }

      timeoutId = setTimeout(execute, wait);

      function execute() {
        func.apply(context, args);
        timeoutId = null;
      }
    };
  }

  function onWindowScrollInternal(e) {
    scrollTop = getDocScrollTop();

    scrollHeight = getDocScrollHeight();
    var windowHeight = getWindowHeight();
    var scrolledToHeight = scrollTop + windowHeight;
    var showAtHeight = (SHOW_POS_PERCENT / 100) *
      scrollHeight;

    if (scrolledToHeight >= showAtHeight) {
      if (WIDGET_TYPE === 'toster') showTosterPopup();
      if (WIDGET_TYPE === 'popup') showPopup();
      w.removeEventListener('scroll', onWindowScroll, false);
    }
  }

  function showTosterPopup() {
    var tosterCollapsed = false;

    addClassName(el, 'relap-' + widgetParams.theme + '__visible');

    handleWidgetShown();
    refreshImgResizers();
    cutTextBlocks();

    var showHideBtn = el.getElementsByClassName('js-relap__visibility-toggle-btn')[0];
    /*вешаем клик*/
    showHideBtn.addEventListener('click', tosterShowHideHandler, false);

    function tosterShowHideHandler(e){
      var collapsedHeight = showHideBtn.offsetHeight - 10;
      var collapsedBottom = - (el.offsetHeight - collapsedHeight);

      if (tosterCollapsed) {
        /*разворачиваем*/
        el.style.bottom = '';
        tosterCollapsed = false;
        this.removeAttribute('data-collapsed');
      } else {
        /*сворачиваем*/
        el.style.bottom = collapsedBottom + 'px';
        tosterCollapsed = true;
        this.setAttribute('data-collapsed', '');
      }
    }
  }

  function showPopup() {
    addClassName(popupWidgetEl, 'relap-' + widgetParams.theme + '__visible');

    handleWidgetShown();
    refreshImgResizers();
    cutTextBlocks();

    var disableScrollElems = [];

    if (widgetParams.disableScrollSelect) {
      disableScrollElems = d.querySelectorAll(widgetParams.disableScrollSelect);
    }

    if (disableScrollElems.length) {
      for (var i = 0; i < disableScrollElems.length; i++) {
        disableScrollElems[i].style.overflow = "hidden";
        disableScrollElems[i].addEventListener('touchmove', preventDefault);
      }
    } else {
      d.documentElement.style.overflow = "hidden";
      d.documentElement.addEventListener('touchmove', preventDefault);
      d.body.style.overflow = "hidden";
      d.body.addEventListener('touchmove', preventDefault);
    }

    var closeButton = popupWidgetEl.getElementsByClassName('js-relap-popup-widget-close')[0];
    closeButton.addEventListener('click', destroyPopup, false);

    onResize();
    window.addEventListener('resize', onResize);
    var intervalId = setInterval(onResize, 500);

    function preventDefault(e) {
      e.preventDefault();
    }

    function destroyPopup(e) {
      e.preventDefault();
      closeButton.removeEventListener('click', destroyPopup);
      clearInterval(intervalId);
      elParent.removeChild(popupWidgetEl);
      window.removeEventListener('resize', onResize);

      if (disableScrollElems.length) {
        for (var i = 0; i < disableScrollElems.length; i++) {
          disableScrollElems[i].style.overflow = "";
          disableScrollElems[i].removeEventListener('touchmove', preventDefault);
        }
      } else {
        d.documentElement.style.overflow = "";
        d.documentElement.removeEventListener('touchmove', preventDefault);
        d.body.style.overflow = "";
        d.body.removeEventListener('touchmove', preventDefault);
      }
    }

    function onResize() {
      var initialTransform = 'translate(-50%, -50%)';
      var popupWidth = popupWidgetEl.offsetWidth;
      var popupHeight = popupWidgetEl.offsetHeight;
      var contentWidth = popupWidgetContentEl.offsetWidth;
      var contentHeight = el.offsetHeight;
      var proportion = popupWidth / contentWidth;

      if (proportion > 1) proportion = 1;
      var translateStr = '';
      var isMobileView = popupWidgetEl.hasAttribute('data-relap-mobile-view');

      if (isMobileView || contentHeight >= popupHeight || contentWidth > popupWidth) {
        addClassName(popupWidgetEl, 'relap-' + widgetParams.theme + '__popup-widget-container--mobile');
        popupWidgetEl.setAttribute('data-relap-mobile-view', '');
      } else {
        translateStr = initialTransform;
        removeClassName(popupWidgetEl, 'relap-' + widgetParams.theme + '__popup-widget-container--mobile');
      }
                                        
      if (isMobileView || contentWidth > popupWidth) {
        var cssStr = translateStr + ' scale(' + proportion + ')'
        popupWidgetContentEl.style.WebkitTransform = cssStr;
        popupWidgetContentEl.style.transform = cssStr;
        var newBottom = popupHeight - popupHeight / proportion;
        popupWidgetContentEl.style.bottom = newBottom + 'px';
      } else {
        popupWidgetContentEl.style.WebkitTransform = translateStr;
        popupWidgetContentEl.style.transform = translateStr;
        popupWidgetContentEl.style.bottom = '';
      }
    }
  }

  function handleInnerLinkClick(e) {
    e.preventDefault();
    e.stopPropagation();
    var innerLink = e.currentTarget;
    var href = innerLink.getAttribute('data-href');
    var target = innerLink.getAttribute('data-target');

    if (!href) return;

    if (target == '_blank') {
      w.open(href);
    } else {
      w.location = href;
    }
  }

  function getDocScrollTop() {
    var html = d.documentElement;
    var body = d.body;
    var scrollTop = html.scrollTop || body && body.scrollTop || 0;
    scrollTop -= html.clientTop;

    return scrollTop;
  }

  function getDocScrollLeft() {
    var html = d.documentElement;
    var body = d.body;
    var scrollLeft = html.scrollLeft || body && body.scrollLeft || 0;

    return scrollLeft;
  }

  function getDocScrollHeight() {
    var scrollHeight = document.documentElement.scrollHeight;
    var clientHeight = document.documentElement.clientHeight;
    scrollHeight = Math.max(scrollHeight, clientHeight);

    return scrollHeight;
  }

  function getWindowHeight() {
    var windowHeight = d.documentElement.clientHeight || 0;

    return windowHeight;
  }

  function addClassName(el, className) {
    var classes = el.className ? el.className.split(' ') : [];

    for (var i = 0; i < classes.length; i++) {
      if (classes[i] == className) return;
    }

    classes.push(className);
    el.className = classes.join(' ');
  }

  function removeClassName(el, className) {
    var classes = el.className.split(' ');

    for (var i = 0; i < classes.length; i++) {
      if (classes[i] == className) classes.splice(i--, 1);
    }
             
    el.className = classes.join(' ');
  }

  function hasClassName(el, className) {
    var classes = el.className.split(' ');

    for (var i = 0; i < classes.length; i++) {
      if (classes[i] == className) return true;
    }

    return false;
  }

  function toggleClassName(el, className) {
    if (hasClassName(el, className)) {
      removeClassName(el, className);
    } else {
      addClassName(el, className);
    }
  }

  
  
function Ellipsizer(el, opt) {
  if (!el) {
    console.warn('ellipsizer: no el given');
    this.update = function() {
      console.warn('ellipsizer: no el to resize');
    };
    return;
  }

  var items = [];
  var ellipsisChar = opt.ellipsisChar || '&hellip;';
  var maxLines = +opt.maxLines || Infinity;
  var cutUntilEl = opt.cutUntilEl;
  var updateOnWindowResize = opt.updateOnWindowResize || false;
  var ellipsizeOverflowingItems;
  var useOwnTrimFunc = opt.useOwnTrimFunc || false;

  if (opt.hasOwnProperty('ellipsizeOverflowingItems')) {
    ellipsizeOverflowingItems = opt.ellipsizeOverflowingItems;
  } else {
    ellipsizeOverflowingItems = false;
  }

  var elRect;
  var cutUntilLine = Infinity;
  var self = this;

  this.update = update;

  init();

  function init() {
    if (maxLines === Infinity) return;

    var text = el.innerText || el.textContent || '';
    text = trim(text);
    parseText();
    prepareHTML();
    updateElRect();

    if (updateOnWindowResize) {
      window.addEventListener('resize', self.update, false);
    }

    function trim(text) {
      if (useOwnTrimFunc || !text.trim) {
        return text.replace(/^\s+|\s+$/gm, '');
      } else {
        return text.trim();
      }
    }

    function parseText() {
      var words = text.split(' ');
      extractPunctuationMarks(words);

      function extractPunctuationMarks(words) {
        for (var i = 0; i < words.length; i++) {
          var lastChar = words[i][words[i].length - 1];

          if (checkLastCharIsPunctuationMark(words[i])) {
            items.push({
              text: words[i].slice(0, -1)
            });

            items.push({
              text: lastChar,
              isPunctuationMark: true
            });

            continue;
          } 

          items.push({
            text: words[i]
          });

          if (checkGlyph(words[i])) {
            items[items.length - 1].isGlyph = true;
          }
        }

        function checkLastCharIsPunctuationMark(word) {
          var lastChar = word[word.length - 1];

          if (lastChar == '.' || lastChar == ',' ||
              lastChar == ':' || lastChar == '?' ||
              lastChar == '!') {
            return true;
          }

          
          if (lastChar == ';' && !checkGlyph(word)) return true;

          return false;
        }

        function checkGlyph(word) {
          var lastChar = word[word.length - 1];

          if (lastChar == ';' && ~word.lastIndexOf('&')) {
            return true;
          }

          if (word == '—') {
            return true;
          }

          return false;
        }
      }
    }

    function prepareHTML() {
      for (var i = 0; i < items.length; i++) {
        var span = document.createElement('span');

        var text = items[i].text;

        if (i != 0 && !items[i].isPunctuationMark) {
          text = ' ' + text;
        }

        span.innerHTML = text;
        items[i].el = span;
      }

      var ellipsis = document.createElement('span');
      ellipsis.innerHTML = ellipsisChar;

      items.push({
        text: ellipsisChar,
        el: ellipsis,
        isEllipsis: true
      });

      el.innerHTML = '';

      for (var i = 0; i < items.length; i++) {
        el.appendChild(items[i].el);
      }
    }
  }

  function updateElRect() {
    elRect = el.getBoundingClientRect();
  }

  function checkRectsOverflowed(parentRect, childRect) {
    if (childRect.right > parentRect.right ||
        childRect.left < parentRect.left) {
      return true;
    }

    return false;
  }

  function update() {
    showAllWords();
    updateElRect();
    updateItemsInfo();
    hideExcessiveWords();

    function showAllWords() {
      for (var i = 0; i < items.length; i++) {
        items[i].isOverflowed = false;
        items[i].isNotInParent = false;

        
        if (items[i].isEllipsis) {
          items[i].isHidden = true;
          items[i].el.style.display = 'none';
          continue;
        }

        items[i].isHidden = false;
        items[i].el.style.display = '';
      }
    }

    function updateItemsInfo() {
      var top = 0;
      var line = 0;

      if (cutUntilEl) {
        cutUntilLine = cutUntilEl.getBoundingClientRect().bottom;
      }

      for (var i = 0; i < items.length; i++) {
        var rect = items[i].el.getBoundingClientRect();
        items[i].rect = rect;

        if (rect.top !== top) {
          line++;
          top = rect.top;
        }

        items[i].line = line;

        if (rect.bottom > cutUntilLine) {
          items[i].isOverflowed = true;
        }

        if (checkRectsOverflowed(elRect, items[i].rect)) {
          items[i].isNotInParent = true;
        }
      }
    }

    function hideExcessiveWords() {
      var isAnyWordHidden = false;
      var ellipsis = items[items.length - 1];
      var notInParentStart;

      if (ellipsizeOverflowingItems) {
        for (var i = 0; i < items.length; i++) {
          if (!notInParentStart && items[i].isNotInParent &&
              !items[i].isEllipsis) {
            notInParentStart = i;
          }

          if (i >= notInParentStart) {
            items[i].isHidden = true;
            isAnyWordHidden = true;
          }
        }
      }

      for (var i = items.length - 1; i >= 0; i--) {
        if (items[i].line > maxLines &&
            !items[i].isEllipsis) {
          items[i].isHidden = true;
          isAnyWordHidden = true;
        }

        if (items[i].isOverflowed &&
            !items[i].isEllipsis) {
          items[i].isHidden = true;
          isAnyWordHidden = true;
        }
      }

      if (isAnyWordHidden) {
        ellipsis.isHidden = false;
        ellipsis.el.style.display = '';

        for (var i = items.length - 1; i >= 0; i--) {
          if (items[i].isHidden) {
            items[i].el.style.display = 'none';
          }
        }

        makeSureEllipsisFits();
      }

      function makeSureEllipsisFits() {
        var lastLineTop = getLastLineTop();

        if (!lastLineTop && !cutUntilLine) return;

        var lastVisibleItemIndex = getLastVisibleItemIndex();

        if (!lastVisibleItemIndex) return;

        updateCutUntilLine();
        updateItemInfo(lastVisibleItemIndex);
        updateEllipsisInfo();
        updateElRect();

        while (items[lastVisibleItemIndex].isOverflowed ||
          items[lastVisibleItemIndex].isNotInParent ||
          ellipsis.rect.top > lastLineTop ||
          items[lastVisibleItemIndex].isPunctuationMark ||
          items[lastVisibleItemIndex].isGlyph) {

          items[lastVisibleItemIndex].isHidden = true;
          items[lastVisibleItemIndex].el.style.display = 'none';

          lastLineTop = getLastLineTop();
          lastVisibleItemIndex = getLastVisibleItemIndex();

          if (!lastVisibleItemIndex) break;

          updateCutUntilLine();
          updateItemInfo(lastVisibleItemIndex);
          updateEllipsisInfo();
          updateElRect();
        }

        function updateEllipsisInfo() {
          updateItemInfo(items.length - 1);
        }

        function updateItemInfo(i) {
          items[i].rect = items[i].el.getBoundingClientRect();

          if (items[i].rect.bottom > cutUntilLine) {
            items[i].isOverflowed = true;
          } else {
            items[i].isOverflowed = false;
          }

          if (!items[i].isHidden &&
              checkRectsOverflowed(elRect, items[i].rect)) {
            items[i].isNotInParent = true;
          } else {
            items[i].isNotInParent = false;
          }
        }

        function updateCutUntilLine() {
          if (cutUntilEl) {
            cutUntilLine = cutUntilEl.getBoundingClientRect().bottom;
          }
        }

        function getLastLineTop() {
          for (var i = 0; i < items.length; i++) {
            if (items[i].line == maxLines &&
                !items[i].isHidden) {
              updateItemInfo(i);
              return items[i].rect.top;
            }
          }

          return Infinity;
        }

        function getLastVisibleItemIndex() {
          for (var i = items.length - 1; i >= 0; i--) {
            if (!items[i].isHidden &&
                !items[i].isEllipsis) {
              return i;
            }
          }

          return null;
        }
      }
    }
  }
}

  
function ImgResizer(opt) {
  var img = opt.img;
  var newAR = opt.aspectRatio || 1;
  var fullWidth = opt.fullWidth;
  var oldAR;
  var focusXpercent = opt.focusXpercent || 50;
  var focusYpercent = opt.focusYpercent || 50;

  var self = this;
  var wrapper;

  this.isReady;
  this.init = init;
  this.update = update;

  init();

  function init() {
    getOldAR();

    var intervalId = setInterval(function() {
      if (oldAR) {
        clearInterval(intervalId);
        self.update();
        self.isReady = true;
        return;
      }

      getOldAR();
    }, 50);

    wrapper = document.createElement('span');
    var imgParent = img.parentNode;
    wrapper.className = 'img-resizer-wrapper';
    wrapper.style.overflow = 'hidden';
    wrapper.style.display = 'inline-block';
    wrapper.style.fontSize = 0;
    
    if (fullWidth) wrapper.style.width = '100%';

    imgParent.insertBefore(wrapper, img);
    wrapper.appendChild(img);

    var arWidth = img.getAttribute('data-img-resizer-ar-width');
    var arHeight = img.getAttribute('data-img-resizer-ar-height');

    if (arWidth && arHeight) {
      newAR = arWidth / arHeight;
    }

    function getOldAR() {
      if (img.clientWidth && img.clientHeight) {
        oldAR = img.clientWidth / img.clientHeight;
      }
    }
  }

  function update(opt) {
    if (opt) {
      newAR = opt.aspectRatio;
    }

    if (!oldAR) return;

    dropStyles();

    if (newAR > oldAR) {
      makeWider();
      return;
    }

    if (newAR < oldAR) {
      makeTaller();
      return;
    }

    function dropStyles() {
      img.style.marginLeft = '';
      img.style.marginRight = '';
      img.style.marginTop = '';
      img.style.marginBottom = '';
      img.style.width = '';
    }

    function makeWider() {
      var marginTotal = (1 / oldAR - 1 / newAR) * 100;
      var marginTop = marginTotal * focusXpercent / 100;
      var marginBottom = marginTotal - marginTop;

      img.style.marginLeft = 'auto';
      img.style.marginRight = 'auto';
      img.style.marginTop = -marginTop + '%';
      img.style.marginBottom = -marginBottom + '%';
    }

    function makeTaller() {
      var cssWidth = oldAR / newAR * 100;
      var marginTotal = cssWidth - 100;
      var marginLeft = marginTotal * focusYpercent / 100;
      var marginRight = marginTotal - marginLeft;

      img.style.width = cssWidth + '%';
      img.style.marginLeft = -marginLeft + '%';
      img.style.marginRight = -marginRight + '%';
      img.style.marginTop = 'auto';
      img.style.marginBottom = 'auto';
    }
  }
}

}

  function calcPageHash() {
/**
 * [js-md5]{@link https://github.com/emn178/js-md5}
 *
 * @namespace md5
 * @version 0.4.0
 * @author Chen, Yi-Cyuan [emn178@gmail.com]
 * @copyright Chen, Yi-Cyuan 2014-2016
 * @license MIT
 */
var md5 = (function (root) {
  'use strict';

  var ARRAY_BUFFER = !root.JS_MD5_TEST && typeof ArrayBuffer != 'undefined';
  var HEX_CHARS = '0123456789abcdef'.split('');
  var EXTRA = [128, 32768, 8388608, -2147483648];
  var SHIFT = [0, 8, 16, 24];
  var OUTPUT_TYPES = ['hex', 'array', 'digest', 'buffer', 'arrayBuffer'];

  var blocks = [], buffer8;
  if (ARRAY_BUFFER) {
    var buffer = new ArrayBuffer(68);
    buffer8 = new Uint8Array(buffer);
    blocks = new Uint32Array(buffer);
  }

  var createOutputMethod = function (outputType) {
    return function (message) {
      return new Md5(true).update(message)[outputType]();
    };
  };

  var createMethod = function () {
    var method = createOutputMethod('hex');
    method.create = function () {
      return new Md5();
    };
    method.update = function (message) {
      return method.create().update(message);
    };
    for (var i = 0;i < OUTPUT_TYPES.length;++i) {
      var type = OUTPUT_TYPES[i];
      method[type] = createOutputMethod(type);
    }
    return method;
  };

  function Md5(sharedMemory) {
    if (sharedMemory) {
      blocks[0] = blocks[16] = blocks[1] = blocks[2] = blocks[3] =
      blocks[4] = blocks[5] = blocks[6] = blocks[7] =
      blocks[8] = blocks[9] = blocks[10] = blocks[11] =
      blocks[12] = blocks[13] = blocks[14] = blocks[15] = 0;
      this.blocks = blocks;
      this.buffer8 = buffer8;
    } else {
      if (ARRAY_BUFFER) {
        var buffer = new ArrayBuffer(68);
        this.buffer8 = new Uint8Array(buffer);
        this.blocks = new Uint32Array(buffer);
      } else {
        this.blocks = [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0];
      }
    }
    this.h0 = this.h1 = this.h2 = this.h3 = this.start = this.bytes = 0;
    this.finalized = this.hashed = false;
    this.first = true;
  }

  Md5.prototype.update = function (message) {
    if (this.finalized) {
      return;
    }
    var notString = typeof(message) != 'string';
    if (notString && message.constructor == root.ArrayBuffer) {
      message = new Uint8Array(message);
    }
    var code, index = 0, i, length = message.length || 0, blocks = this.blocks;
    var buffer8 = this.buffer8;

    while (index < length) {
      if (this.hashed) {
        this.hashed = false;
        blocks[0] = blocks[16];
        blocks[16] = blocks[1] = blocks[2] = blocks[3] =
        blocks[4] = blocks[5] = blocks[6] = blocks[7] =
        blocks[8] = blocks[9] = blocks[10] = blocks[11] =
        blocks[12] = blocks[13] = blocks[14] = blocks[15] = 0;
      }

      if (notString) {
        if (ARRAY_BUFFER) {
          for (i = this.start;index < length && i < 64; ++index) {
            buffer8[i++] = message[index];
          }
        } else {
          for (i = this.start;index < length && i < 64; ++index) {
            blocks[i >> 2] |= message[index] << SHIFT[i++ & 3];
          }
        }
      } else {
        if (ARRAY_BUFFER) {
          for (i = this.start;index < length && i < 64; ++index) {
            code = message.charCodeAt(index);
            if (code < 0x80) {
              buffer8[i++] = code;
            } else if (code < 0x800) {
              buffer8[i++] = 0xc0 | (code >> 6);
              buffer8[i++] = 0x80 | (code & 0x3f);
            } else if (code < 0xd800 || code >= 0xe000) {
              buffer8[i++] = 0xe0 | (code >> 12);
              buffer8[i++] = 0x80 | ((code >> 6) & 0x3f);
              buffer8[i++] = 0x80 | (code & 0x3f);
            } else {
              code = 0x10000 + (((code & 0x3ff) << 10) | (message.charCodeAt(++index) & 0x3ff));
              buffer8[i++] = 0xf0 | (code >> 18);
              buffer8[i++] = 0x80 | ((code >> 12) & 0x3f);
              buffer8[i++] = 0x80 | ((code >> 6) & 0x3f);
              buffer8[i++] = 0x80 | (code & 0x3f);
            }
          }
        } else {
          for (i = this.start;index < length && i < 64; ++index) {
            code = message.charCodeAt(index);
            if (code < 0x80) {
              blocks[i >> 2] |= code << SHIFT[i++ & 3];
            } else if (code < 0x800) {
              blocks[i >> 2] |= (0xc0 | (code >> 6)) << SHIFT[i++ & 3];
              blocks[i >> 2] |= (0x80 | (code & 0x3f)) << SHIFT[i++ & 3];
            } else if (code < 0xd800 || code >= 0xe000) {
              blocks[i >> 2] |= (0xe0 | (code >> 12)) << SHIFT[i++ & 3];
              blocks[i >> 2] |= (0x80 | ((code >> 6) & 0x3f)) << SHIFT[i++ & 3];
              blocks[i >> 2] |= (0x80 | (code & 0x3f)) << SHIFT[i++ & 3];
            } else {
              code = 0x10000 + (((code & 0x3ff) << 10) | (message.charCodeAt(++index) & 0x3ff));
              blocks[i >> 2] |= (0xf0 | (code >> 18)) << SHIFT[i++ & 3];
              blocks[i >> 2] |= (0x80 | ((code >> 12) & 0x3f)) << SHIFT[i++ & 3];
              blocks[i >> 2] |= (0x80 | ((code >> 6) & 0x3f)) << SHIFT[i++ & 3];
              blocks[i >> 2] |= (0x80 | (code & 0x3f)) << SHIFT[i++ & 3];
            }
          }
        }
      }
      this.lastByteIndex = i;
      this.bytes += i - this.start;
      if (i >= 64) {
        this.start = i - 64;
        this.hash();
        this.hashed = true;
      } else {
        this.start = i;
      }
    }
    return this;
  };

  Md5.prototype.finalize = function () {
    if (this.finalized) {
      return;
    }
    this.finalized = true;
    var blocks = this.blocks, i = this.lastByteIndex;
    blocks[i >> 2] |= EXTRA[i & 3];
    if (i >= 56) {
      if (!this.hashed) {
        this.hash();
      }
      blocks[0] = blocks[16];
      blocks[16] = blocks[1] = blocks[2] = blocks[3] =
      blocks[4] = blocks[5] = blocks[6] = blocks[7] =
      blocks[8] = blocks[9] = blocks[10] = blocks[11] =
      blocks[12] = blocks[13] = blocks[14] = blocks[15] = 0;
    }
    blocks[14] = this.bytes << 3;
    this.hash();
  };

  Md5.prototype.hash = function () {
    var a, b, c, d, bc, da, blocks = this.blocks;

    if (this.first) {
      a = blocks[0] - 680876937;
      a = (a << 7 | a >>> 25) - 271733879 << 0;
      d = (-1732584194 ^ a & 2004318071) + blocks[1] - 117830708;
      d = (d << 12 | d >>> 20) + a << 0;
      c = (-271733879 ^ (d & (a ^ -271733879))) + blocks[2] - 1126478375;
      c = (c << 17 | c >>> 15) + d << 0;
      b = (a ^ (c & (d ^ a))) + blocks[3] - 1316259209;
      b = (b << 22 | b >>> 10) + c << 0;
    } else {
      a = this.h0;
      b = this.h1;
      c = this.h2;
      d = this.h3;
      a += (d ^ (b & (c ^ d))) + blocks[0] - 680876936;
      a = (a << 7 | a >>> 25) + b << 0;
      d += (c ^ (a & (b ^ c))) + blocks[1] - 389564586;
      d = (d << 12 | d >>> 20) + a << 0;
      c += (b ^ (d & (a ^ b))) + blocks[2] + 606105819;
      c = (c << 17 | c >>> 15) + d << 0;
      b += (a ^ (c & (d ^ a))) + blocks[3] - 1044525330;
      b = (b << 22 | b >>> 10) + c << 0;
    }

    a += (d ^ (b & (c ^ d))) + blocks[4] - 176418897;
    a = (a << 7 | a >>> 25) + b << 0;
    d += (c ^ (a & (b ^ c))) + blocks[5] + 1200080426;
    d = (d << 12 | d >>> 20) + a << 0;
    c += (b ^ (d & (a ^ b))) + blocks[6] - 1473231341;
    c = (c << 17 | c >>> 15) + d << 0;
    b += (a ^ (c & (d ^ a))) + blocks[7] - 45705983;
    b = (b << 22 | b >>> 10) + c << 0;
    a += (d ^ (b & (c ^ d))) + blocks[8] + 1770035416;
    a = (a << 7 | a >>> 25) + b << 0;
    d += (c ^ (a & (b ^ c))) + blocks[9] - 1958414417;
    d = (d << 12 | d >>> 20) + a << 0;
    c += (b ^ (d & (a ^ b))) + blocks[10] - 42063;
    c = (c << 17 | c >>> 15) + d << 0;
    b += (a ^ (c & (d ^ a))) + blocks[11] - 1990404162;
    b = (b << 22 | b >>> 10) + c << 0;
    a += (d ^ (b & (c ^ d))) + blocks[12] + 1804603682;
    a = (a << 7 | a >>> 25) + b << 0;
    d += (c ^ (a & (b ^ c))) + blocks[13] - 40341101;
    d = (d << 12 | d >>> 20) + a << 0;
    c += (b ^ (d & (a ^ b))) + blocks[14] - 1502002290;
    c = (c << 17 | c >>> 15) + d << 0;
    b += (a ^ (c & (d ^ a))) + blocks[15] + 1236535329;
    b = (b << 22 | b >>> 10) + c << 0;
    a += (c ^ (d & (b ^ c))) + blocks[1] - 165796510;
    a = (a << 5 | a >>> 27) + b << 0;
    d += (b ^ (c & (a ^ b))) + blocks[6] - 1069501632;
    d = (d << 9 | d >>> 23) + a << 0;
    c += (a ^ (b & (d ^ a))) + blocks[11] + 643717713;
    c = (c << 14 | c >>> 18) + d << 0;
    b += (d ^ (a & (c ^ d))) + blocks[0] - 373897302;
    b = (b << 20 | b >>> 12) + c << 0;
    a += (c ^ (d & (b ^ c))) + blocks[5] - 701558691;
    a = (a << 5 | a >>> 27) + b << 0;
    d += (b ^ (c & (a ^ b))) + blocks[10] + 38016083;
    d = (d << 9 | d >>> 23) + a << 0;
    c += (a ^ (b & (d ^ a))) + blocks[15] - 660478335;
    c = (c << 14 | c >>> 18) + d << 0;
    b += (d ^ (a & (c ^ d))) + blocks[4] - 405537848;
    b = (b << 20 | b >>> 12) + c << 0;
    a += (c ^ (d & (b ^ c))) + blocks[9] + 568446438;
    a = (a << 5 | a >>> 27) + b << 0;
    d += (b ^ (c & (a ^ b))) + blocks[14] - 1019803690;
    d = (d << 9 | d >>> 23) + a << 0;
    c += (a ^ (b & (d ^ a))) + blocks[3] - 187363961;
    c = (c << 14 | c >>> 18) + d << 0;
    b += (d ^ (a & (c ^ d))) + blocks[8] + 1163531501;
    b = (b << 20 | b >>> 12) + c << 0;
    a += (c ^ (d & (b ^ c))) + blocks[13] - 1444681467;
    a = (a << 5 | a >>> 27) + b << 0;
    d += (b ^ (c & (a ^ b))) + blocks[2] - 51403784;
    d = (d << 9 | d >>> 23) + a << 0;
    c += (a ^ (b & (d ^ a))) + blocks[7] + 1735328473;
    c = (c << 14 | c >>> 18) + d << 0;
    b += (d ^ (a & (c ^ d))) + blocks[12] - 1926607734;
    b = (b << 20 | b >>> 12) + c << 0;
    bc = b ^ c;
    a += (bc ^ d) + blocks[5] - 378558;
    a = (a << 4 | a >>> 28) + b << 0;
    d += (bc ^ a) + blocks[8] - 2022574463;
    d = (d << 11 | d >>> 21) + a << 0;
    da = d ^ a;
    c += (da ^ b) + blocks[11] + 1839030562;
    c = (c << 16 | c >>> 16) + d << 0;
    b += (da ^ c) + blocks[14] - 35309556;
    b = (b << 23 | b >>> 9) + c << 0;
    bc = b ^ c;
    a += (bc ^ d) + blocks[1] - 1530992060;
    a = (a << 4 | a >>> 28) + b << 0;
    d += (bc ^ a) + blocks[4] + 1272893353;
    d = (d << 11 | d >>> 21) + a << 0;
    da = d ^ a;
    c += (da ^ b) + blocks[7] - 155497632;
    c = (c << 16 | c >>> 16) + d << 0;
    b += (da ^ c) + blocks[10] - 1094730640;
    b = (b << 23 | b >>> 9) + c << 0;
    bc = b ^ c;
    a += (bc ^ d) + blocks[13] + 681279174;
    a = (a << 4 | a >>> 28) + b << 0;
    d += (bc ^ a) + blocks[0] - 358537222;
    d = (d << 11 | d >>> 21) + a << 0;
    da = d ^ a;
    c += (da ^ b) + blocks[3] - 722521979;
    c = (c << 16 | c >>> 16) + d << 0;
    b += (da ^ c) + blocks[6] + 76029189;
    b = (b << 23 | b >>> 9) + c << 0;
    bc = b ^ c;
    a += (bc ^ d) + blocks[9] - 640364487;
    a = (a << 4 | a >>> 28) + b << 0;
    d += (bc ^ a) + blocks[12] - 421815835;
    d = (d << 11 | d >>> 21) + a << 0;
    da = d ^ a;
    c += (da ^ b) + blocks[15] + 530742520;
    c = (c << 16 | c >>> 16) + d << 0;
    b += (da ^ c) + blocks[2] - 995338651;
    b = (b << 23 | b >>> 9) + c << 0;
    a += (c ^ (b | ~d)) + blocks[0] - 198630844;
    a = (a << 6 | a >>> 26) + b << 0;
    d += (b ^ (a | ~c)) + blocks[7] + 1126891415;
    d = (d << 10 | d >>> 22) + a << 0;
    c += (a ^ (d | ~b)) + blocks[14] - 1416354905;
    c = (c << 15 | c >>> 17) + d << 0;
    b += (d ^ (c | ~a)) + blocks[5] - 57434055;
    b = (b << 21 | b >>> 11) + c << 0;
    a += (c ^ (b | ~d)) + blocks[12] + 1700485571;
    a = (a << 6 | a >>> 26) + b << 0;
    d += (b ^ (a | ~c)) + blocks[3] - 1894986606;
    d = (d << 10 | d >>> 22) + a << 0;
    c += (a ^ (d | ~b)) + blocks[10] - 1051523;
    c = (c << 15 | c >>> 17) + d << 0;
    b += (d ^ (c | ~a)) + blocks[1] - 2054922799;
    b = (b << 21 | b >>> 11) + c << 0;
    a += (c ^ (b | ~d)) + blocks[8] + 1873313359;
    a = (a << 6 | a >>> 26) + b << 0;
    d += (b ^ (a | ~c)) + blocks[15] - 30611744;
    d = (d << 10 | d >>> 22) + a << 0;
    c += (a ^ (d | ~b)) + blocks[6] - 1560198380;
    c = (c << 15 | c >>> 17) + d << 0;
    b += (d ^ (c | ~a)) + blocks[13] + 1309151649;
    b = (b << 21 | b >>> 11) + c << 0;
    a += (c ^ (b | ~d)) + blocks[4] - 145523070;
    a = (a << 6 | a >>> 26) + b << 0;
    d += (b ^ (a | ~c)) + blocks[11] - 1120210379;
    d = (d << 10 | d >>> 22) + a << 0;
    c += (a ^ (d | ~b)) + blocks[2] + 718787259;
    c = (c << 15 | c >>> 17) + d << 0;
    b += (d ^ (c | ~a)) + blocks[9] - 343485551;
    b = (b << 21 | b >>> 11) + c << 0;

    if (this.first) {
      this.h0 = a + 1732584193 << 0;
      this.h1 = b - 271733879 << 0;
      this.h2 = c - 1732584194 << 0;
      this.h3 = d + 271733878 << 0;
      this.first = false;
    } else {
      this.h0 = this.h0 + a << 0;
      this.h1 = this.h1 + b << 0;
      this.h2 = this.h2 + c << 0;
      this.h3 = this.h3 + d << 0;
    }
  };

  Md5.prototype.hex = function () {
    this.finalize();

    var h0 = this.h0, h1 = this.h1, h2 = this.h2, h3 = this.h3;

    return HEX_CHARS[(h0 >> 4) & 0x0F] + HEX_CHARS[h0 & 0x0F] +
       HEX_CHARS[(h0 >> 12) & 0x0F] + HEX_CHARS[(h0 >> 8) & 0x0F] +
       HEX_CHARS[(h0 >> 20) & 0x0F] + HEX_CHARS[(h0 >> 16) & 0x0F] +
       HEX_CHARS[(h0 >> 28) & 0x0F] + HEX_CHARS[(h0 >> 24) & 0x0F] +
       HEX_CHARS[(h1 >> 4) & 0x0F] + HEX_CHARS[h1 & 0x0F] +
       HEX_CHARS[(h1 >> 12) & 0x0F] + HEX_CHARS[(h1 >> 8) & 0x0F] +
       HEX_CHARS[(h1 >> 20) & 0x0F] + HEX_CHARS[(h1 >> 16) & 0x0F] +
       HEX_CHARS[(h1 >> 28) & 0x0F] + HEX_CHARS[(h1 >> 24) & 0x0F] +
       HEX_CHARS[(h2 >> 4) & 0x0F] + HEX_CHARS[h2 & 0x0F] +
       HEX_CHARS[(h2 >> 12) & 0x0F] + HEX_CHARS[(h2 >> 8) & 0x0F] +
       HEX_CHARS[(h2 >> 20) & 0x0F] + HEX_CHARS[(h2 >> 16) & 0x0F] +
       HEX_CHARS[(h2 >> 28) & 0x0F] + HEX_CHARS[(h2 >> 24) & 0x0F] +
       HEX_CHARS[(h3 >> 4) & 0x0F] + HEX_CHARS[h3 & 0x0F] +
       HEX_CHARS[(h3 >> 12) & 0x0F] + HEX_CHARS[(h3 >> 8) & 0x0F] +
       HEX_CHARS[(h3 >> 20) & 0x0F] + HEX_CHARS[(h3 >> 16) & 0x0F] +
       HEX_CHARS[(h3 >> 28) & 0x0F] + HEX_CHARS[(h3 >> 24) & 0x0F];
  };

  Md5.prototype.toString = Md5.prototype.hex;

  Md5.prototype.digest = function () {
    this.finalize();

    var h0 = this.h0, h1 = this.h1, h2 = this.h2, h3 = this.h3;
    return [
      h0 & 0xFF, (h0 >> 8) & 0xFF, (h0 >> 16) & 0xFF, (h0 >> 24) & 0xFF,
      h1 & 0xFF, (h1 >> 8) & 0xFF, (h1 >> 16) & 0xFF, (h1 >> 24) & 0xFF,
      h2 & 0xFF, (h2 >> 8) & 0xFF, (h2 >> 16) & 0xFF, (h2 >> 24) & 0xFF,
      h3 & 0xFF, (h3 >> 8) & 0xFF, (h3 >> 16) & 0xFF, (h3 >> 24) & 0xFF
    ];
  };

  Md5.prototype.array = Md5.prototype.digest;

  Md5.prototype.arrayBuffer = function () {
    this.finalize();

    var buffer = new ArrayBuffer(16);
    var blocks = new Uint32Array(buffer);
    blocks[0] = this.h0;
    blocks[1] = this.h1;
    blocks[2] = this.h2;
    blocks[3] = this.h3;
    return buffer;
  };

  Md5.prototype.buffer = Md5.prototype.arrayBuffer;

  var exports = createMethod();

  /**
   * @method md5
   * @description Md5 hash function, export to global in browsers.
   * @param {String|Array|Uint8Array|ArrayBuffer} message message to hash
   * @returns {String} md5 hashes
   * @example
   * md5(''); // d41d8cd98f00b204e9800998ecf8427e
   * md5('The quick brown fox jumps over the lazy dog'); // 9e107d9d372bb6826bd81d3542a419d6
   * md5('The quick brown fox jumps over the lazy dog.'); // e4d909c290d0fb1ca068ffaddf22cbd0
   *
   * // It also supports UTF-8 encoding
   * md5('中文'); // a7bac2239fcdcb3a067903d8077c4a07
   *
   * // It also supports byte `Array`, `Uint8Array`, `ArrayBuffer`
   * md5([]); // d41d8cd98f00b204e9800998ecf8427e
   * md5(new Uint8Array([])); // d41d8cd98f00b204e9800998ecf8427e
   */
  return exports;
}(this));


        var version = 1;

        var token   = '';

        var title   = '';
        var descr   = '';
        var image   = '';

        var isArticle = '';

	var elem;

        
        if      ( elem = document.querySelector('meta[name="relap-title"]')  ) title = elem.getAttribute('content');
        else if ( elem = document.querySelector('meta[property="og:title"]') ) title = elem.getAttribute('content');
        else if ( elem = document.querySelector('meta[itemprop="name"]') )     title = elem.getAttribute('content');
        else if ( elem = document.getElementsByTagName('title') ) {

		if ( elem.length > 0 ) title = elem[0].innerText;
	}
        
        if      ( elem = document.querySelector('meta[name="relap-description"]')  ) descr = elem.getAttribute('content');
        else if ( elem = document.querySelector('meta[property="og:description"]') ) descr = elem.getAttribute('content');
        else if ( elem = document.querySelector('meta[name="description"]')        ) descr = elem.getAttribute('content');
        else if ( elem = document.querySelector('meta[itemprop="description"]')    ) descr = elem.getAttribute('content');
        
        if      ( elem = document.querySelector('meta[name="relap-image"]')  ) image = elem.getAttribute('content');
        else if ( elem = document.querySelector('meta[property="og:image"]') ) image = elem.getAttribute('content');
        else if ( elem = document.querySelector('meta[itemprop="image"]') )    image = elem.getAttribute('content');

        
        if ( elem = document.querySelector('meta[property="relap:article"]') ) isArticle = elem.getAttribute('content');

        var s = [title, descr, image, isArticle].join("\t");

        var pageHash = md5(s);
        log('pageHash server: 68df036258919b2010fe32794ffc43a1');
        log('pageHash current: ' + pageHash);

        if ( '68df036258919b2010fe32794ffc43a1' == pageHash ) return '';

        return pageHash;
}

function getPageHashParam() {

    var pageHash = calcPageHash();

    if ( pageHash ) return '&phash=' + pageHash;

    return '';
}



  })(window, document);
} catch (e) {
  if (window.console && window.console.log && typeof(window.console.log) == 'function') {window.console.log(e);}
}
